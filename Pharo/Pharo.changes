----QUIT----2020-01-22T20:54:30.239682+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!----QUIT----2020-01-22T20:54:52.539489+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!!Sich class methodsFor: 'accessing'!active	^ active! !!Sich class methodsFor: 'accessing'!neoJsonMapping: mappermapper for: self do: [ :mapping | mapping mapInstVars: #(cossacks money) ]! !!Sich class methodsFor: 'accessing'!server	^ server! !!Sich class methodsFor: 'server'!startServer| sich teapot | sich := self new. teapot := Teapot allInstances last. teapot ifNil: [ teapot := Teapot  ]. teapot stop. teapot := Teapot configure: { #defaultOutput -> #json. #port -> 9090. #debugMode -> true}.teapot	GET: '/sichStats' -> sich;	PUT: '/sendSupport/<sloboda_id>/money/<value>' -> [:req | sich addMoney: ((req at: #value) asInteger) fromSloboda: (req at: #sloboda_id)];	PUT: '/sendSupport/<sloboda_id>/cossacks/<value>' -> [:req | sich addCossacks: ((req at: #value) asInteger) fromSloboda: (req at: #sloboda_id)].		teapot start.	server := teapot.			active := sich. 	^ sich ! !!Sich class methodsFor: 'server'!stopServerserver stop! !!Sich methodsFor: 'accessing'!addCossacks: aNumbercossacks := cossacks + (aNumber asNumber)! !!Sich methodsFor: 'accessing'!addCossacks: aNumber fromSloboda: aSloboda|sloboda|cossacks := cossacks + (aNumber asNumber).sloboda := (registry at: aSloboda ifAbsentPut: (Sloboda withName: aSloboda withMoney: 0 withCossacks: 0 )).sloboda addCossacks: aNumber.sloboda! !!Sich methodsFor: 'accessing'!addMoney: aNumbermoney := money + (aNumber asNumber)! !!Sich methodsFor: 'accessing'!addMoney: aNumber fromSloboda: aSloboda|sloboda|money := money + (aNumber asNumber).sloboda := (registry at: aSloboda ifAbsentPut: (Sloboda withName: aSloboda withMoney: 0 withCossacks: 0 )).sloboda addMoney: aNumber.sloboda  ! !!Sich methodsFor: 'accessing'!cossacks	^ cossacks! !!Sich methodsFor: 'accessing'!gtPreviewFor: aView <gtView>^ aView textEditor  text: 'Money: ', self money asString, '  |  ', 'Cossacks: ', self cossacks asString, ' | Slobodas contributed: ', registry size asString;  title: 'Sloboda Stats'! !!Sich methodsFor: 'accessing'!initializemoney := 0.cossacks := 0.registry := Dictionary new! !!Sich methodsFor: 'accessing'!money	^ money! !!Sloboda class methodsFor: 'as yet unclassified'!withName: aName withMoney: aMoney withCossacks: aCossacks|c|c := self new.c name: aName.c money: aMoney.c cossacks: aCossacks.^c! !!Sloboda methodsFor: 'adding'!addCossacks: aCossackscossacks := cossacks + aCossacks! !!Sloboda methodsFor: 'adding'!addMoney: aMoneymoney := money + aMoney! !!Sloboda methodsFor: 'accessing'!cossacks	^ cossacks! !!Sloboda methodsFor: 'accessing'!cossacks: anObject	cossacks := anObject! !!Sloboda methodsFor: 'gt-inspector-extension'!gtPreviewFor: aView <gtView>^ aView textEditor  text: 'Sloboda name: ', name, ' has Money: ', self money asString, '  |  ', 'Cossacks: ', self cossacks asString;  title: 'Sloboda Stats'! !!Sloboda methodsFor: 'initialization'!initializemoney := 0.cossacks := 0.name = 'No name'! !!Sloboda methodsFor: 'accessing'!money	^ money! !!Sloboda methodsFor: 'accessing'!money: anObject	money := anObject! !!Sloboda methodsFor: 'accessing'!name	^ name! !!Sloboda methodsFor: 'accessing'!name: anObject	name := anObject! !"Sloboda"!!MCGitBasedNetworkRepository methodsFor: '*Iceberg' stamp: 'AutoDeprecationRefactoring 3/14/2020 22:13' prior: 50352198!createIcebergRepositoryWithFallbackFor: remote url: remoteUrl	| urlToUse |	urlToUse := remoteUrl.	[ ^ self createIcebergRepositoryFor: urlToUse ]		on: IceAuthenticationError		do: [ :e | 			self				crTrace:					('I got an error while cloning: {1}. I will try to clone the HTTPS variant.'						format: {e messageText}).			urlToUse := remote httpsUrl.			e retry ]! !!BaselineOfTeapot methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ 			self setUpDependencies: spec.						spec				package: 'Teapot-Core' with: [ spec requires: #('NeoJSON') ];				package: 'Teapot-Tests' with: [ spec requires: 'Teapot-Core' ];				package: 'Teapot-Tools' with: [ spec requires: 'Teapot-Core' ].			spec				group: 'Tests' with: #('Teapot-Tests');				group: 'Tools' with: #('Teapot-Tools');				group: 'Deployment' with: #('Teapot-Core');				group: 'Development' with: #('Tests' 'Tools');				group: 'default' with: 'Development' ]! !!BaselineOfTeapot methodsFor: 'baselines'!setUpDependencies: spec	spec		baseline: 'NeoJSON'		with: [ spec				repository: 'github://svenvc/NeoJSON:master/repository';				loads: #('core') ]! !"BaselineOfTeapot"!!BaselineOfNeoJSON commentStamp: '' prior: 0!I am BaselineOfNeoJSON, I load the code for the NeoJSON project.I am a BaselineOf.!!BaselineOfNeoJSON methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec				package: 'Neo-JSON-Core';				package: 'Neo-JSON-Tests' with: [ spec requires: #('Neo-JSON-Core') ];				group: 'default' with: #('core' 'tests');				group: 'core' with: #('Neo-JSON-Core');				group: 'tests' with: #('Neo-JSON-Tests') ].	spec		for: #pharo		do: [ spec				package: 'Neo-JSON-Pharo-Core' with: [ spec requires: #('Neo-JSON-Core') ];				package: 'Neo-JSON-Pharo-Tests' with: [ spec requires: #('Neo-JSON-Tests') ];				package: 'Neo-JSON-Pharo-Examples' with: [ spec requires: #('Neo-JSON-Core') ];								group: 'core' with: #('Neo-JSON-Core' 'Neo-JSON-Pharo-Core');				group: 'tests' with: #('Neo-JSON-Tests' 'Neo-JSON-Pharo-Tests');				group: 'examples' with: #('Neo-JSON-Pharo-Examples') ].! !"BaselineOfNeoJSON"!!NeoJSONMapper commentStamp: '' prior: 0!I am NeoJSONMapper.I hold a mapping from schema identifiers to objects that known how to read or write instances from or to JSON.Schema identifiers are either Smalltalk classes or Symbols.I offer a builder interface to construct mappings. The standard object mapping represents a Smalltalk object as a map, mapping some or all instance variables, or a set of accessors (getter/setter methods). Furthermore, for each value an optional schema can be specified.Using a custom mapping, a reader and/or writer block can deal with special cases such as specific collection types with an optional schema for the elements, or a direct mapping of semi primitive types such as Date or DateAndTime.A mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.Here are some examples:	mapper mapAllInstVarsFor: Point.	mapper for: TestObject do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]!!NeoJSONReader commentStamp: '' prior: 0!I am NeoJSONReader.I am a NeoJSONMapper.I parse a JSON representation from a textual stream into Smalltalk objects.Primitive types are automatically mapped to their Smalltalk counterpart: Numbers, Strings, Booleans and UndefinedObject.When parsing using #next, lists normally become Arrays and maps become Dictionaries.An alternative listClass or mapClass can be specified.When parsing using #nextAs: a schema can be specified. This schema defines a mapping to be used.Here are some examples:	NeoJSONReader fromString: ' [ 1,2,3 ] '.	NeoJSONReader fromString: ' [ 3.14159, true, false, null, "string" ] '.	NeoJSONReader fromString: ' { "x" : 1, "y" : 2 } '.		(NeoJSONReader on: ' { "x" : 1, "y" : 2 } ' readStream)		mapInstVarsFor: Point;		nextAs: Point.					(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		for: #ArrayOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ArrayOfPoints.	(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		nextListAs: Point.!!NeoJSONWriter commentStamp: '' prior: 0!I am NeoJSONWriter.I am a NeoJSONMapper.I write a JSON representation of Smalltalk objects to a textual stream.Objects implementing #neoJsonOn: can be encoded.A number of primitive types, like Strings, Numbers, Booleans and UndefinedObject are treated specially.Collection are encoded as lists, except for Dictionaries that are encoded as maps.All other objects need a mapping to help in doing the encoding.Here are some examples:	NeoJSONWriter toString: #(1 2 3).	NeoJSONWriter toString: { Float pi. true. false. 'string' }.	NeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).		String streamContents: [ :stream |		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: (Array with: 1@3 with: -1@3) ].	!!NeoJSONMapping commentStamp: '' prior: 0!I am NeoJSONMapping, an abstract superclass for mapping definitions.!!NeoJSONCustomMapping commentStamp: '' prior: 0!I am NeoJSONCustomMapping.I read the next JSON value and turn it into a Smalltalk object using a converter block.!!NeoJSONObjectMapping commentStamp: '' prior: 0!I am NeoJSONObjectMapping.I describe how instances of a Smalltalk class are mapped to a JSON map.I do this using set of NeoJSONPropertyMappings.I know the Smalltalk class that I am a mapping for. This class is the schema identifier and is used to instanciate new objects.A mapping can be based on any combination of instance variables or accessors (getter/setter pairs). I offer a builder interface to constuct property mappings.!!NeoJSONPropertyMapping commentStamp: '' prior: 0!I am NeoJSONPropertyMapping.I describe how a property of a Smalltalk class maps to a JSON property.A property is either an instance variable or getter/setter pair.I hold a getter and setter block to do the actual work. The property name is used in JSON.Optionally, the schema for the value of my property can be specified. This is then used recursively.!!NeoJSONStreamingWriter commentStamp: '' prior: 0!I am NeoJSONStreamingWriter.I help in writing streamed maps and lists.This is an internal class used by NeoJSONWriter to deal with interleaving elements and separators as well as pretty printing.!!NeoJSONMappingNotFound commentStamp: '' prior: 0!I am NeoJSONMappingNotFound. I am signalled when no mapping is found for a schema.Portability comment: In Pharo,  I could technically subclass from NotFound directly, avoid all my defined methods and only keep #messageText and #standardMessageText. However, NotFound exception does not exist in other dialects. To keep NeoJSON as portable as possible we duplicate some Pharo code into myself. !!NeoJSONParseError commentStamp: '' prior: 0!I am NeoJSONParseError.I am an Error.I am signalled when JSON input is not valid while parsing.!!NeoJSONObject commentStamp: '' prior: 0!I am NeoJSONObject.I am a Dictionary.I behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.The following are equivalent:	self foo.	self at: #foo.As are the following	self foo: 1. 	self at: #foo put: 1.	Except that in the first case, self is returned.I can optionally be used by NeoJSONReader as mapClass (see #mapClass:).For output, I act just like my superclass (it is thus not necessary to do any conversions).Example:	NeoJSONObject fromString: '{"foo":1,"bar":-2}'.	NeoJSONObject new foo: 1; bar: -2.	{ #x -> 100. #y -> 200 } as: NeoJSONObject.	(NeoJSONObject new data: (NeoJSONObject new id: #sensor1; value: 37.5)) asString.I use JSON as my printed representation. To convert me to JSON, use #printString or #asString.Additionally, I support path access for nested instances of me, using #atPath: and #atPath:put:The first is special because it returns nil as soon as a key is missing. The second is special because it creates extra levels (instances of me) as needed to follow the path of keys.	NeoJSONObject new atPath: #(one two three) put: 42; yourself.	NeoJSONObject new atPath: #(one two three) put: 42; atPath: #(one two three).		!!Collection methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeList: self! !!Boolean methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeBoolean: self! !!UndefinedObject methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeNull! !!NeoJSONMapper methodsFor: 'private'!customMappingFor: schemaName	^ self mappings		at: schemaName		ifAbsentPut: [ 			NeoJSONCustomMapping new				schemaName: schemaName;				yourself ]! !!NeoJSONMapper methodsFor: 'mapping'!for: schemaName customDo: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new custom mapping for schemaName if necessary."		| mapping |	mapping := self customMappingFor: schemaName.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'mapping'!for: smalltalkClass do: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new standard object mapping for schemaName if necessary."		| mapping |	mapping := self objectMappingFor: smalltalkClass.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience'!mapAllInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass and all its super classes"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapAllInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience'!mapInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'accessing'!mappingFor: schema	^ self 		mappingFor: schema 		ifAbsent: [ NeoJSONMappingNotFound signalFor: schema in: self ]! !!NeoJSONMapper methodsFor: 'accessing'!mappingFor: schema ifAbsent: block	(self mappings includesKey: schema)		ifFalse: [ self resolveMappingFor: schema ].	^ self mappings		at: schema		ifAbsent: block! !!NeoJSONMapper methodsFor: 'private'!mappings	^ mappings		ifNil: [ mappings := Dictionary new ]! !!NeoJSONMapper methodsFor: 'private'!objectMappingFor: smalltalkClass	^ self mappings		at: smalltalkClass		ifAbsentPut: [ 			NeoJSONObjectMapping new				subjectClass: smalltalkClass;				yourself ]! !!NeoJSONMapper methodsFor: 'private'!resolveMappingFor: class	(class respondsTo: #neoJsonMapping:)		ifTrue: [ 			class perform: #neoJsonMapping: with: self ]! !!NeoJSONReader class methodsFor: 'convenience'!fromString: string	^ (self on: string readStream) next! !!NeoJSONReader class methodsFor: 'convenience'!fromString: string as: schema	^ (self on: string readStream) nextAs: schema! !!NeoJSONReader class methodsFor: 'instance creation'!on: readStream	"Initialize on readStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."	^ self new		on: readStream;		yourself! !!NeoJSONReader methodsFor: 'testing'!atEnd	^ readStream atEnd! !!NeoJSONReader methodsFor: 'initialize-release'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!NeoJSONReader methodsFor: 'private'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ 			readStream next ]! !!NeoJSONReader methodsFor: 'private'!error: text	NeoJSONParseError signal: text! !!NeoJSONReader methodsFor: 'private'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!NeoJSONReader methodsFor: 'parsing'!failIfNotAtEnd	self atEnd		ifFalse: [ self error: 'extraneous input detected' ]! !!NeoJSONReader methodsFor: 'initialize-release'!initialize 	super initialize.	propertyNamesAsSymbols := false! !!NeoJSONReader methodsFor: 'accessing'!listClass	"Return the collection type to use for JSON lists"		^ listClass ifNil: [ Array ]! !!NeoJSONReader methodsFor: 'initialize-release'!listClass: collectionClass	listClass := collectionClass! !!NeoJSONReader methodsFor: 'accessing'!mapClass	"Return the collection type to use for JSON maps"		^ mapClass ifNil: [ Dictionary ]! !!NeoJSONReader methodsFor: 'initialize-release'!mapClass: collectionClass	mapClass := collectionClass! !!NeoJSONReader methodsFor: 'private'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!NeoJSONReader methodsFor: 'private'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end.	When character does not match, return false and leave stream untouched."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!NeoJSONReader methodsFor: 'accessing'!next	"Primary interface to parse a JSON value.	Return either primitives, a listClass or a mapClass instance."		^ self 		consumeWhitespace; 		parseValue! !!NeoJSONReader methodsFor: 'accessing'!nextAs: schema	"Secondary interface to parse JSON.	Return an object according to schema.	If schema is nil, act like #next"		| mapping |	schema ifNil: [ ^ self next ].	self consumeWhitespace.	mapping := self mappingFor: schema.	^ mapping readFrom: self! !!NeoJSONReader methodsFor: 'accessing'!nextListAs: schema	"Secondary interface to parse JSON.	Return a list of objects, each element according to schema."		^ self listClass streamContents: [ :stream |			self parseListDo: [ 				stream nextPut: (self nextAs: schema) ] ]! !!NeoJSONReader methodsFor: 'initialize-release'!on: aReadStream	"Initialize on aReadStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."		readStream := aReadStream! !!NeoJSONReader methodsFor: 'parsing'!parseCharacter	| char |	(char := readStream next) = $\ 		ifFalse: [ ^ char ].	('/"\' includes: (char := readStream next))		ifTrue: [ ^ char ].	('bfnrt' includes: char)		ifTrue: [ ^ self unescapeChar: char ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	char 		ifNil: [ self error: 'invalid escape, end of file' ]		ifNotNil: [ self error: 'invalid escape character \' , char asString ]! !!NeoJSONReader methodsFor: 'private'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint ].	^ Character codePoint: codePoint! !!NeoJSONReader methodsFor: 'private'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!NeoJSONReader methodsFor: 'private'!parseCharacterHexDigit	| digit |	readStream atEnd 		ifFalse: [ 			digit := readStream next asInteger.			(digit between: "$0" 48 and: "$9" 57)				ifTrue: [ ^ digit - 48 ].			(digit between: "$A" 65 and: "$F" 70)				ifTrue: [ ^ digit - 55 ].			(digit between: "$a" 97 and: "$f" 102)				ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!NeoJSONReader methodsFor: 'private'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			^ self match: 'null' do: [ block value: nil ] ]! !!NeoJSONReader methodsFor: 'parsing'!parseList	^ self listClass 		streamContents: [ :stream |			self parseListElementsDo: [ :each |				stream nextPut: each ] ]		! !!NeoJSONReader methodsFor: 'parsing'!parseListDo: block	self expectChar: $[.	(self matchChar: $]) 		ifTrue: [ ^ self ].	[ readStream atEnd ] 		whileFalse: [			block value.			(self matchChar: $]) 				ifTrue: [ ^ self ].			(self matchChar: $,)				ifFalse: [ self error: ', or ] expected' ] ].	self error: 'incomplete list'! !!NeoJSONReader methodsFor: 'parsing'!parseListElementsDo: block	self parseListDo: [ 		block value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing'!parseMap	| map |	map := self mapClass new.	self parseMapKeysAndValuesDo: [ :key :value |		map at: key put: value ].	^ map! !!NeoJSONReader methodsFor: 'parsing'!parseMapDo: block	self expectChar: ${.	(self matchChar: $})		ifTrue: [ ^ self ].	[ readStream atEnd ] whileFalse: [		block value.		(self matchChar: $}) 			ifTrue: [ ^ self ].		(self matchChar: $,)			ifFalse: [ self error: ', or } expected' ] ].	self error: 'incomplete map'! !!NeoJSONReader methodsFor: 'parsing'!parseMapKeysAndValuesDo: block	self parseMapKeysDo: [ :key |		block value: key value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing'!parseMapKeysDo: block	self parseMapDo: [ | key |		key := self parsePropertyName.		self expectChar: $:.		block value: key ]! !!NeoJSONReader methodsFor: 'parsing'!parseNumber	| negated number |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	(readStream peekFor: $.)		ifTrue: [ number := number + self parseNumberFraction ].	((readStream peekFor: $e) or: [ readStream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!NeoJSONReader methodsFor: 'parsing'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	(readStream atEnd or: [ readStream peek isDigit not ])		ifTrue: [ self error: 'number exponent expected' ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	number positive 		ifTrue: [ number > Float emax ifTrue: [ self error: 'number exponent too large' ] ]		ifFalse: [ number < Float emin ifTrue: [ self error: 'number exponent too small' ] ].	^ 10 raisedTo: number! !!NeoJSONReader methodsFor: 'parsing'!parseNumberFraction	| number power |	number := 0.	power := 1.0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [			number := 10 * number + readStream next digitValue.			power := power * 10.0 ].	^ number / power! !!NeoJSONReader methodsFor: 'parsing'!parseNumberInteger	| number |	number := nil.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [ 			number := 10 * (number ifNil: [ 0 ]) + readStream next digitValue ].	number ifNil: [ self error: 'Integer digit expected' ].	^ number! !!NeoJSONReader methodsFor: 'parsing'!parsePropertyName	| name |	name := self parseValue.	^ name isString		ifTrue: [ 			propertyNamesAsSymbols 				ifTrue: [ name asSymbol ]				ifFalse: [ name ] ]		ifFalse: [ 			self error: 'property name must be a string, not ', name asString ]! !!NeoJSONReader methodsFor: 'parsing'!parseString	| result |	(readStream peekFor: $")		ifFalse: [ self error: '" expected' ].	result := self stringStreamContents: [ :stream | 		[ readStream atEnd or: [ readStream peek = $" ] ] 			whileFalse: [ stream nextPut: self parseCharacter ] ].	self expectChar: $".	^ result! !!NeoJSONReader methodsFor: 'private'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!NeoJSONReader methodsFor: 'parsing'!parseValue	| char |	readStream atEnd ifFalse: [ 		char := readStream peek.		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input: ', char asString! !!NeoJSONReader methodsFor: 'initialize-release'!propertyNamesAsSymbols: boolean	propertyNamesAsSymbols := boolean! !!NeoJSONReader methodsFor: 'private'!stringStreamContents: block	"Like String streamContents: block	but reusing the underlying buffer for improved efficiency"		stringStream 		ifNil: [ 			stringStream := (String new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!NeoJSONReader methodsFor: 'private'!unescapeChar: char	"Handle one of the named character escapes, b, f, n, r or t. Else fail."		char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	self error: 'Unknown escape char: ', (String with: char)! !!NeoJSONWriter class methodsFor: 'instance creation'!on: writeStream	"Initialize on writeStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	^ self new		on: writeStream;		yourself! !!NeoJSONWriter class methodsFor: 'convenience'!toString: object	^ String streamContents: [ :stream |			(self on: stream) nextPut: object ]! !!NeoJSONWriter class methodsFor: 'convenience'!toStringPretty: object	^ String streamContents: [ :stream |			(self on: stream)				prettyPrint: true; 				nextPut: object ]! !!NeoJSONWriter methodsFor: 'initialize-release'!asciiOnly: boolean	"Set whether I should escape all non ASCII characters or not"		asciiOnly := boolean! !!NeoJSONWriter methodsFor: 'initialize-release'!close	"Close the stream that I write to"		writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!NeoJSONWriter methodsFor: 'private'!doesCodePointNeedEscaping: code	code < 32 ifTrue: [ ^ true ].	( code = 34 or: [ code = 92 ]) ifTrue: [ ^ true ].	^ asciiOnly and: [ code > 126 ]	! !!NeoJSONWriter methodsFor: 'private'!encodeChar: char	| code |	code := char codePoint.	(self doesCodePointNeedEscaping: code)		ifTrue: [ self escapeChar: code ]		ifFalse: [ writeStream nextPut: char ]! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key	key isString ifFalse: [ ^ self error: 'JSON key names in objects must be strings' ].	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key value: value	self encodeKey: key.	self nextPut: value! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key value: value as: valueSchema	self encodeKey: key.	self nextPut: value as: valueSchema! !!NeoJSONWriter methodsFor: 'private'!escapeChar: code	code = 34		ifTrue: [ ^ writeStream nextPutAll: '\"' ].	code = 92		ifTrue: [ ^ writeStream nextPutAll: '\\' ].	code = 47		ifTrue: [ ^ writeStream nextPutAll: '\/' ].	code = 8		ifTrue: [ ^ writeStream nextPutAll: '\b' ].	code = 12		ifTrue: [ ^ writeStream nextPutAll: '\f' ].			code = 10		ifTrue: [ ^ writeStream nextPutAll: '\n' ].			code = 13		ifTrue: [ ^ writeStream nextPutAll: '\r' ].			code = 9		ifTrue: [ ^ writeStream nextPutAll: '\t' ].			self escapeUnicode: code! !!NeoJSONWriter methodsFor: 'private'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!NeoJSONWriter methodsFor: 'private'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!NeoJSONWriter methodsFor: 'private'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!NeoJSONWriter methodsFor: 'initialize-release'!initialize	super initialize.	"For portability reasons use `Character cr asString` rather than `String cr`"	self newLine: Character cr asString.	self prettyPrint: false.	self asciiOnly: false.	self writeNil: false.	level := 0! !!NeoJSONWriter methodsFor: 'private'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'private'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'initialize-release'!newLine: string	"Set the newline string that I should use when pretty printing"		newLine := string! !!NeoJSONWriter methodsFor: 'accessing'!newline	"Write a newline on the stream that I wrap.	What gets written depends on the configuration, see #newLine:"		writeStream nextPutAll: newLine! !!NeoJSONWriter methodsFor: 'private'!newlineIndent	prettyPrint		ifTrue: [ 			self newline.			level timesRepeat: [ writeStream nextPut: Character tab ] ]! !!NeoJSONWriter methodsFor: 'accessing'!nextPut: anObject	"Primary interface. Write a JSON representation of anObject to my stream."		anObject neoJsonOn: self! !!NeoJSONWriter methodsFor: 'accessing'!nextPut: anObject as: schema	"Secondary interface to write JSON.	Write objects according to schema."		| mapping |	(schema isNil or: [ anObject isNil ]) ifTrue: [ ^ self nextPut: anObject ].	mapping := self mappingFor: schema.	^ mapping writeObject: anObject on: self! !!NeoJSONWriter methodsFor: 'initialize-release'!on: aWriteStream	"Initialize on aWriteStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	writeStream := aWriteStream! !!NeoJSONWriter methodsFor: 'initialize-release'!prettyPrint: boolean	"Set whether I should pretty print the JSON that I write"	prettyPrint := boolean! !!NeoJSONWriter methodsFor: 'private'!prettyPrintSpace	prettyPrint		ifTrue: [ writeStream nextPut: Character space ]! !!NeoJSONWriter methodsFor: 'writing'!writeBoolean: boolean	boolean printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing'!writeFloat: float	float printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing'!writeInteger: integer	integer printOn: writeStream	! !!NeoJSONWriter methodsFor: 'writing'!writeList: collection	self writeListStreamingDo: [ :jsonListWriter |		collection do: [ :each |			jsonListWriter writeElement: each ] ]! !!NeoJSONWriter methodsFor: 'writing'!writeListStreamingDo: block	writeStream nextPut: $[.	self writeStreamingDo: block.	writeStream nextPut: $]! !!NeoJSONWriter methodsFor: 'writing'!writeMap: keyValueCollection	self writeMapStreamingDo: [ :jsonMapWriter |		keyValueCollection keysAndValuesDo: [ :key :value |			jsonMapWriter writeKey: key value: value ] ]! !!NeoJSONWriter methodsFor: 'writing'!writeMapStreamingDo: block	writeStream nextPut: ${.	self writeStreamingDo: block.	writeStream nextPut: $}! !!NeoJSONWriter methodsFor: 'accessing'!writeNil	"Return whether I will write nil/null properties of objects or skip them."		^ writeNil! !!NeoJSONWriter methodsFor: 'initialize-release'!writeNil: boolean	"Set whether I will write nil/null properties of objects or skip them."		writeNil := boolean! !!NeoJSONWriter methodsFor: 'writing'!writeNull	writeStream nextPutAll: 'null'! !!NeoJSONWriter methodsFor: 'writing'!writeObject: anObject	| mapping |	mapping := self mappingFor: anObject class.	mapping		writeObject: anObject		on: self! !!NeoJSONWriter methodsFor: 'writing'!writeStreamingDo: block	| mapWriter |	mapWriter := NeoJSONStreamingWriter on: self.	self indentedDo: [		block value: mapWriter ].	mapWriter wasUsed		ifTrue: [ self newlineIndent ]		ifFalse: [ self prettyPrintSpace ]! !!NeoJSONWriter methodsFor: 'writing'!writeString: string	writeStream nextPut: $".	1 to: string size do: [ :index |		self encodeChar: (string at: index) ].	writeStream nextPut: $"! !!NeoJSONCustomMapping methodsFor: 'mapping'!decoder: block	"Set a decoder block that accepts the next object representation read 	and converts it into the actual object to be returned."	self reader: [ :jsonReader | | representation |		representation := jsonReader next.		block value: representation ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!encoder: block	"Set a encoder block that accepts the next object to be written 	and converts it into the actual representation to be written."	self writer: [ :jsonWriter :anObject | | representation |		representation := block value: anObject.		jsonWriter nextPut: representation ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!identifier	^ schemaName ! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfElementSchema: elementSchema	"Set the reader to a block that will create an instance of the	standard listClass while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		jsonReader listClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each | listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfType: collectionClass	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader next.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient, no element type known anyway"! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfType: collectionClass andElementSchema: elementSchema	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each | 				listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!mapWithValueSchema: valueSchema	"Set the reader to a block that will create an instance of the	standard mapClass while reading values of type valueSchema,	with standard keys"	self reader: [ :jsonReader | | map |		map := jsonReader mapClass new.		jsonReader parseMapKeysDo: [ :key | | value |				value := jsonReader nextAs: valueSchema.				map at: key put: value ].		map ].	self writer: [ :jsonWriter :map | 		jsonWriter writeMapStreamingDo: [ :mapWriter |			map keysAndValuesDo: [ :key :value | 				mapWriter writeKey: key value: value as: valueSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'parsing'!readFrom: jsonReader	^ reader 		ifNil: [ jsonReader next ]		ifNotNil: [ reader value: jsonReader ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!reader: block	"Set the reader to block, a 1 argument block that when given 	a jsonReader as argument reads the object that I represent.	When there is no reader block, the default #next will be used."		reader := block! !!NeoJSONCustomMapping methodsFor: 'accessing'!schemaName: schema	schemaName := schema! !!NeoJSONCustomMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	writer 		ifNil: [ anObject neoJsonOn: jsonWriter ]		ifNotNil: [ writer value: jsonWriter value: anObject ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!writer: block	"Set the writer to block, a 2 argument block that when given: a jsonWriter 	and the object to write will write the object that I represent.	When there is no writer block, the default #neoJsonOn: will be used."		writer := block! !!NeoJSONMapping methodsFor: 'accessing'!identifier	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: self identifier; nextPut: $)! !!NeoJSONMapping methodsFor: 'parsing'!readFrom: jsonReader	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	self subclassResponsibility ! !!NeoJSONObjectMapping methodsFor: 'initialize-release'!allowNil	"Set that I will allow nil/null values when I read/expect an object"		allowNil := true! !!NeoJSONObjectMapping methodsFor: 'accessing'!identifier	^ subjectClass ! !!NeoJSONObjectMapping methodsFor: 'initialize-release'!initialize	super initialize.	properties := OrderedCollection new.	allowNil := false! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor	^ self mapAccessor: accessor to: accessor ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor mutator: mutator to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: mutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: accessor asMutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessors: accessors	^ accessors collect: [ :each | self mapAccessor: each ]! !!NeoJSONObjectMapping methodsFor: 'convenience'!mapAllInstVars	^ self mapInstVars: subjectClass allInstVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVar: instVarName	^ self mapInstVar: instVarName to: instVarName ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVar: instVarName to: propertyName	| index |	index := 		"For portability reasons, do not use instVarIndexFor:ifAbsent: 		(it doesn't exist in all Smalltalk dialects) but the below approach.		Also, convert to symbols for portability reasons"		(subjectClass allInstVarNames collect: [ :each | each asSymbol ]) 			indexOf: instVarName asSymbol 			ifAbsent: [ self error: 'Inst var not found: ', instVarName printString ].	^ self 		mapProperty: propertyName asString		getter: [ :object | object instVarAt: index ]		setter: [ :object :value | object instVarAt: index put: value ] 	! !!NeoJSONObjectMapping methodsFor: 'convenience'!mapInstVars	^ self mapInstVars: subjectClass instVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVars: instVarNames	^ instVarNames collect: [ :each | self mapInstVar: each ]! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapProperty: propertyName getter: readBlock setter: writeBlock	| propertyMapping |	propertyMapping := NeoJSONPropertyMapping new.	propertyMapping 		propertyName: propertyName;		getter: readBlock;		setter: writeBlock.	properties removeAllSuchThat: [ :each | each propertyName = propertyMapping propertyName ].	properties addLast: propertyMapping.	^ propertyMapping ! !!NeoJSONObjectMapping methodsFor: 'accessing'!propertyNamed: propertyName ifAbsent: block	| symbolPropertyName |	symbolPropertyName := propertyName asSymbol.	^ properties detect: [ :each | each propertyName = symbolPropertyName ] ifNone: block! !!NeoJSONObjectMapping methodsFor: 'parsing'!readFrom: jsonReader	| anObject |	anObject := subjectClass new.	allowNil ifTrue: [ 		jsonReader parseConstantDo: [ :value | 			^ value ifNotNil: [ jsonReader error: 'Unexpected boolean constant' ] ] ].	jsonReader parseMapKeysDo: [ :key |		(self propertyNamed: key ifAbsent: [ nil ])			ifNil: [				"read, skip & ignore value"				jsonReader next ]			ifNotNil: [ :mapping |				mapping readObject: anObject from: jsonReader ] ].	^ anObject! !!NeoJSONObjectMapping methodsFor: 'accessing'!subjectClass: smalltalkClass	subjectClass := smalltalkClass! !!NeoJSONObjectMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	jsonWriter writeMapStreamingDo: [ :jsonMapWriter |		properties do: [ :each |			each writeObject: anObject on: jsonMapWriter ] ]! !!NeoJSONPropertyMapping methodsFor: 'accessing'!getter: block	getter := block! !!NeoJSONPropertyMapping methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: propertyName; nextPut: $)! !!NeoJSONPropertyMapping methodsFor: 'accessing'!propertyName	^ propertyName ! !!NeoJSONPropertyMapping methodsFor: 'accessing'!propertyName: symbolOrString	propertyName := symbolOrString asSymbol! !!NeoJSONPropertyMapping methodsFor: 'parsing'!readObject: anObject from: jsonReader	| value |	value := jsonReader nextAs: valueSchema.	setter value: anObject value: value! !!NeoJSONPropertyMapping methodsFor: 'accessing'!setter: block	setter := block! !!NeoJSONPropertyMapping methodsFor: 'accessing'!valueSchema: schemaName	valueSchema := schemaName! !!NeoJSONPropertyMapping methodsFor: 'writing'!writeObject: anObject on: jsonMapWriter	| value |	value := getter value: anObject.	(value notNil or: [ jsonMapWriter writeNil ])		ifTrue: [ jsonMapWriter writeKey: propertyName value: value as: valueSchema ] ! !!NeoJSONStreamingWriter class methodsFor: 'instance creation'!on: jsonWriter	^ self new		on: jsonWriter;		yourself! !!NeoJSONStreamingWriter methodsFor: 'initialize-release'!initialize	super initialize.	first := true! !!NeoJSONStreamingWriter methodsFor: 'initialize-release'!on: aJSONWriter	jsonWriter := aJSONWriter! !!NeoJSONStreamingWriter methodsFor: 'testing'!wasUsed	^ first not! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeElement: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value ! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeElement: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeKey: key value: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value ! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeKey: key value: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'accessing'!writeNil	^ jsonWriter writeNil! !!Object methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeObject: self! !!String methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeString: self! !!NeoJSONMappingNotFound class methodsFor: 'instance creation'!signalFor: anObject	"Create and signal an exception for anObject in the default receiver."		^ self new		object: anObject;		signal! !!NeoJSONMappingNotFound class methodsFor: 'instance creation'!signalFor: anObject in: aCollection	"Create and signal an exception for anObject in aCollection."	^ self new		object: anObject;		collection: aCollection;		signal! !!NeoJSONMappingNotFound methodsFor: 'accessing'!collection	"Return the collection where something is not found in"		^ collection! !!NeoJSONMappingNotFound methodsFor: 'accessing'!collection: aCollection	"Set the collection where something is not found in"		collection := aCollection! !!NeoJSONMappingNotFound methodsFor: 'accessing'!messageText	"Overwritten with standard text. To ease portability to other Smalltalk dialects we do not access the instVar 'messageText' as not all dialects have it. Not caching the value on the instVar shouldn't bring any performance hit in this case. "		^ self standardMessageText ! !!NeoJSONMappingNotFound methodsFor: 'accessing'!object	"Return the object that was not found"		^ object! !!NeoJSONMappingNotFound methodsFor: 'accessing'!object: anObject	"Set the object that was not found"		object := anObject! !!NeoJSONMappingNotFound methodsFor: 'private'!standardMessageText	^ String streamContents: [ :stream |		stream << 'No mapping found for '.		stream print: self object.		stream << ' in '.		stream print: self collection class ]! !!Integer methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeInteger: self! !!Number methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeFloat: self asFloat! !!Dictionary methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!NeoJSONObject class methodsFor: 'convenience'!fromString: string	"Parse string as JSON, so that maps become instances of me"	^ (NeoJSONReader on: string readStream)			mapClass: NeoJSONObject;			propertyNamesAsSymbols: true;			next! !!NeoJSONObject methodsFor: 'accessing'!at: key	"I return nil for missing keys.	My superclass would signal a KeyNotFound."		^ self at: key ifAbsent: [ nil ]! !!NeoJSONObject methodsFor: 'accessing'!atPath: keyCollection	"Use each key in keyCollection recursively, stop when nil is encountered"		| value |	value := self.	keyCollection do: [ :each |		value := value at: each.		value ifNil: [ ^ nil ] ].	^ value ! !!NeoJSONObject methodsFor: 'accessing'!atPath: keyCollection put: newValue	"Use each key in keyCollection recursively, create new levels when needed"		| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		(target at: each)			ifNil: [ target := target at: each put: target species new ]			ifNotNil: [ :subValue | target := subValue ] ].	^ target at: keyCollection last put: newValue! !!NeoJSONObject methodsFor: 'reflective operations'!doesNotUnderstand: message	"Overwritten so that 'self foo' becomes 'self at: #foo'	and 'self foo: 1' becomes 'self at: #foo put: 1' except that self is returned"		| key |	key := message selector.	key isUnary		ifTrue: [ ^ self at: key ].	^ (key isKeyword and: [ key numArgs = 1 ])		ifTrue: [ self at: key allButLast asSymbol put: message arguments first; yourself ]		ifFalse: [ super doesNotUnderstand: message ]! !!NeoJSONObject methodsFor: 'accessing'!name	"Overwritten to make this accessor available as key"		^ self at: #name! !!NeoJSONObject methodsFor: 'printing'!printOn: stream	"I use my JSON representation when printing myself"	[ (NeoJSONWriter on: stream) nextPut: self ]		on: Error		do: [ :exception | 			stream				nextPutAll: ' Error printing JSON: ';				nextPutAll: exception printString ]! !!NeoJSONObject methodsFor: 'evaluating'!value	"Overwritten to make this accessor available as key"		^ self at: #value! !"Neo-JSON-Core"!!OrderedDictionary methodsFor: '*neo-json-pharo-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!SmallDictionary methodsFor: '*neo-json-pharo-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!TeaNoSuchParam commentStamp: '' prior: 0!This exception indicates that the given parameter was not found in the TeaRequest.!!TeaAbort commentStamp: '' prior: 0!I'm an exception that immediately stops a request within a filter or route.!!IsObject commentStamp: '' prior: 0!I'm the base class of the type constraints. I match to any object. My subclasses can restict the type of placeholders.Example:Teapot on	GET: '/user/<id:IsInteger>' -> [:req | users findById: (req at: #id)];	start.This route matches to the '/users/12' but does not match to '/users/foobar'. In case of matching, the the path paramter "id" will be converted to an integer.You can extend the built in type constraints with your own constraints, by implementing the "placeholder type constraint" protocol. Then you can use the class name in the URL.!!IsInteger commentStamp: '' prior: 0!I'm a type constraint that matches to positive or negative integers.!!IsNumber commentStamp: '' prior: 0!I'm a type constraint that matches to positive or negative floats or integers.!!IsUUID commentStamp: '' prior: 0!I'm a type constraint that matches to an UUID.!!Send commentStamp: '' prior: 0!I can send messages to objects on a http requests. The selector of the message can take maximum 2 arguments ( TeaRequest and TeaResponse).Example:Teapot on	GET: '/hi' -> (Send message: #greet to: controller);	start.	!!TeaErrorHandler commentStamp: '' prior: 0!An error handler handles Exceptions signaled by the Routes or before actions.!!TeaFilter commentStamp: '' prior: 0!After and Before filters!!TeaAfterFilter commentStamp: '' prior: 0!An after filter is evaluated after each (matching) request. This filter has access to the response object generated by the matching route. The response can be modified from the filter, e.g. addition headers can be added.!!TeaBeforeFilter commentStamp: '' prior: 0!A before filter is evaluated before (matching) each request. This filter has access to the request object. For example, a before filter can be used to validate session attributes for authentication.!!TeaGlobUrlSegment commentStamp: '' prior: 0!My subclasses form the elements of TeaGlobUrlPatterns!!TeaLiteral commentStamp: '' prior: 0!A literal url pattern segment that matches to a string.!!TeaLiteralStop commentStamp: '' prior: 0!I'm a placeholder at the last position.!!TeaPlaceholder commentStamp: '' prior: 0!I'm a placeholder with a key. My content is substituted with a value.!!TeaPlaceholderStop commentStamp: '' prior: 0!I'm a placeholder at the last position.!!TeaWildcard commentStamp: '' prior: 0!A wildcard url pattern segment that matches to anything.!!TeaWildcardStop commentStamp: '' prior: 0!I'm a Wildcard at the last position.!!TeaMethodMatcher commentStamp: '' prior: 0!I can be matched against an HTTP method. I will return either true or false.!!TeaNotFoundHandler commentStamp: '' prior: 0!I decides what response to return when there were not matching routes (and no static path) for the incoming request. By default I just return 404.!!Tea405AwareNotFoundHandler commentStamp: '' prior: 0!I'm a smarter not found handler that returns 405 instead of 404 when the url part of some routes matched but the HTTP method didn't.!!TeaOutput commentStamp: '' prior: 0!I have various response transformer methods on my class side, that can be used as follows:Teapot on	GET: '/books' -> books; output: #json;	start.	Some of the transformers require optional dependencies, like Neo-JSON, STON, or Mustache.!!TeaPadding commentStamp: '' prior: 0!An url is padded by me, if its size is to short. I don't match to any literal URL, so it's like I'm not there.!!TeaRequest commentStamp: '' prior: 0!I extend the ZnRequest with addition methods for convenience.!!TeaRequestMatcher commentStamp: '' prior: 0!I can be matched against a ZnRequest. I check the http method and url of the request. !!TeaResponse commentStamp: '' prior: 0!A TeaResponse represents an HTTP response returned by a Route. The ZnResponse is generated from the TeaResponse by the given response transformer.!!TeaRoute commentStamp: '' prior: 0!A route handles http requests if it matches to the route. I have four major parts.- A handler that can be a block, a value or a message send.- An url pattern that can be matched against actual urls.- An http method that can be matched against the actual http method.- A response transformer for creating ZnResponse from the object returned by the handler.!!TeaRouter commentStamp: '' prior: 0!A zn delegate baseclass!!TeaCompositeRouter commentStamp: '' prior: 0!I'm a composite zn delegate, built from other zn delegates. I forward the request to the first delegate that returns other than 404 as response. Errors are handled with the help of the registered error handlers.!!TeaDynamicRouter commentStamp: '' prior: 0!I'm a ZnDelegate. I serve dynamically generated contents. The request is handled by the first route object, that returns other than 404 as response.!!TeaStaticRouter commentStamp: '' prior: 0!I'm a ZnDelegate based on ZnStaticFileServerDelegate. I serve static content from a file system directory.!!TeaUrlPattern commentStamp: '' prior: 0!An URL pattern can be matched agains actual urls. The pattern may collect named parameters from the URL in case of match.!!TeaGlobUrlPattern commentStamp: '' prior: 0!An UrlPattern is made from segments. I can be matched against an actual URL. '*' and <named-parameters> can be used inside the pattern.I can parse the pattern from a string by saying:	self parseString: '/foo/*/<id>/bar'Which will create a pattern that matches to an URL like this: 	/foo/xyz/12/bar!!TeaRxUrlPattern commentStamp: '' prior: 0!I'm an URL pattern that uses a regular expression internally. I collect subexpressions in case of matching.!!TeaUrlPatternSet commentStamp: '' prior: 0!I match to the given url if any of my elements match.E.g.Teapot on	GET: {'/a'. '/b'} -> 'ab';	start.		Both ZnEasy get: '/a' and ZnEasy get: '/b' returns 'ab'!!Teapot commentStamp: '' prior: 0!I'm the Teapot server on top of ZnServer. I can handle URL routing as follows:Teapot on      GET: '/hi' -> 'Hello World!!';      GET: '/a/*/b' -> (Send message: #ab: to: controller);      GET: '/users' -> [ users ]; output: #json	      GET: '/user/<id>' -> [ :req | (req at: #id) ]; output: #ston;      PUT: '/books/<id>' -> [ :req | | book |	  book := Book author: (req at: #author) title: (req at: #title).        books at: (req at: #id) put: book ]; 	  output: #ston;      start.For more configuration option see the Teapot class>>configure method.!!ZnResponse methodsFor: '*Teapot-Core'!teaTransform: aResponseTransformer request: aTeaRequest	^ self! !!RxMatcher methodsFor: '*Teapot-Core'!asTeaUrlPattern	^ TeaRxUrlPattern fromRxMatcher: self! !!String methodsFor: '*Teapot-Core'!asTeaUrlPattern	^ TeaGlobUrlPattern parseString: self! !!TeaNoSuchParam class methodsFor: 'signaling'!signalWithParam: aSymbol	(self new setParam: aSymbol) signal: 'Param ', aSymbol printString, ' not found'! !!TeaNoSuchParam methodsFor: 'accessing'!param	^ param! !!TeaNoSuchParam methodsFor: 'initialization'!setParam: aSymbol	param := aSymbol.	^ self! !!TeaAbort class methodsFor: 'instance creation'!response: aZnResponse	^ self new setResponse: aZnResponse! !!TeaAbort methodsFor: 'converting'!response	^ response! !!TeaAbort methodsFor: 'initialization'!setResponse: aZnResponse	response := aZnResponse.	^ self! !!BlockClosure methodsFor: '*Teapot-Core'!teaEvalActionOnException: anException request: aTeaRequest	^ self cull: anException cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core'!teaEvalActionOnRequest: aTeaRequest	^ self cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ self cull: aTeaRequest cull: aZnResponse! !!IsInteger class methodsFor: 'type constraint'!matchesTo: aString	^ '-?\d+' asRegex matches: aString! !!IsInteger class methodsFor: 'type constraint'!parseString: aString	^ aString asInteger! !!IsNumber class methodsFor: 'type constraint'!matchesTo: aString	Number readFrom: aString ifFail: [ ^false ].	^ true! !!IsNumber class methodsFor: 'type constraint'!parseString: aString	^ aString asNumber! !!IsObject class methodsFor: 'type constraint'!matchesTo: aString	^ true! !!IsObject class methodsFor: 'type constraint'!parseString: aString	^ aString! !!IsUUID class methodsFor: 'type constraint'!matchesTo: aString	^ '[0-9a-f]{8}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{12}' asRegex matches: aString! !!IsUUID class methodsFor: 'type constraint'!parseString: aString	^ UUID fromString: aString! !!Object methodsFor: '*Teapot-Core'!teaEvalActionOnException: anException request: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core'!teaEvalActionOnRequest: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: (TeaResponse ok body: self) cull: aTeaRequest! !!Send class methodsFor: 'instance creation'!message: aSymbol to: anObject	^ self new 		setSelector: aSymbol 		receiver: anObject! !!Send methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: '(Send message: ';		nextPutAll: selector printString;		nextPutAll: ' to: '.	receiver printOn: aStream.	aStream nextPut: $)! !!Send methodsFor: 'initialization'!setSelector: aSymbol receiver: anObject	selector := aSymbol.	receiver := anObject.	^ self	! !!Send methodsFor: 'tea action'!teaEvalActionOnException: anException request: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { anException. aTeaRequest }	! !!Send methodsFor: 'tea action'!teaEvalActionOnRequest: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest }	! !!Send methodsFor: 'tea action'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest. aZnResponse }	! !!TeaErrorHandler class methodsFor: 'instance creation'!for: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	^ self new 		setExceptions: anExceptionSet 		action: aTeaAction 		responseTransformer: aResponseTransformer! !!TeaErrorHandler methodsFor: 'error handler'!canHandleError: anException	^ exceptions handles: anException! !!TeaErrorHandler methodsFor: 'error handler'!handleError: anException request: aTeaRequest	| result |	^ (self canHandleError: anException)		ifTrue:			[ result := action teaEvalActionOnException: anException request: aTeaRequest.			result teaTransform: responseTransformer request: aTeaRequest ]		ifFalse: 			[ self error: 'Cannot handle ', anException printString ]! !!TeaErrorHandler methodsFor: 'error handler'!responseTransformer: aResponseTransformer 	responseTransformer := aResponseTransformer! !!TeaErrorHandler methodsFor: 'initialization'!setExceptions: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	exceptions := anExceptionSet.	action := aTeaAction.	responseTransformer := aResponseTransformer.	^ self! !!TeaAfterFilter methodsFor: 'response handling'!handleRequest: aZnRequest response: aZnResponse	requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest response: aZnResponse ]		ifNoMatch: [ ]! !!TeaBeforeFilter methodsFor: 'request handling'!handleRequest: aZnRequest	requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest ]		ifNoMatch: [ ]! !!TeaFilter class methodsFor: 'instance creation'!urlPattern: anUrlPattern action: aTeaAction	^ self new 		setMatcher: (TeaRequestMatcher method: TeaMethodMatcher any url: anUrlPattern)		action: aTeaAction! !!TeaFilter methodsFor: 'acccessing'!action	^action! !!TeaFilter methodsFor: 'acccessing'!requestMatcher	^requestMatcher! !!TeaFilter methodsFor: 'initialization'!setMatcher: aTeaRequestMatcher action: aTeaAction	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	^ self! !!TeaFilter methodsFor: 'acccessing'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure ! !!TeaGlobUrlSegment methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	self subclassResponsibility! !!TeaLiteral class methodsFor: 'instance creation'!fromString: aString atLast: aBoolean	| class |	class := aBoolean ifTrue: [ TeaLiteralStop ] ifFalse: [ TeaLiteral ].	^ class new setLiteral: aString! !!TeaLiteral methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ literal = urlSegments first and: 		[ adjacentPatterns first 			matches: urlSegments allButFirst 			rest: adjacentPatterns allButFirst 			placeholders: aDictionary ]! !!TeaLiteral methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: literal.	! !!TeaLiteral methodsFor: 'initialization'!setLiteral: aString	literal := aString.	^ self! !!TeaLiteralStop methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ urlSegments size = 1 and: [ literal = urlSegments first ]! !!TeaPlaceholder class methodsFor: 'private'!createPlaceholderName: key typeConstraint: aTypeConstraint atLast: aBoolean	| class |	class := aBoolean		ifTrue: [ TeaPlaceholderStop ]		ifFalse: [ TeaPlaceholder ].	^ class new 		setPlaceholderName: key 		typeConstraint: aTypeConstraint! !!TeaPlaceholder class methodsFor: 'instance creation'!fromString: aString atLast: aBoolean	| spec typeConstraint key |	self mustBeValidPlaceholder: aString.	spec := aString allButFirst allButLast findTokens: ':'.	key := spec first.	typeConstraint := spec at: 2 ifAbsent: #IsObject.	^ self 		createPlaceholderName: key 		typeConstraint: (Smalltalk at: typeConstraint asSymbol)		atLast: aBoolean! !!TeaPlaceholder class methodsFor: 'private'!mustBeValidPlaceholder: aString	((aString beginsWith: '<') and: [ aString endsWith: '>' ])		ifFalse: [ self error: 'Invalid placeholder name: ', aString ]! !!TeaPlaceholder methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	(urlSegments first = TeaPadding or: [ (typeConstraint matchesTo: urlSegments first) not]) 		ifTrue: [ ^ false ].			aDictionary 		at: placeholderName 		put: (typeConstraint parseString: urlSegments first).					^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaPlaceholder methodsFor: 'printing'!printOn: aStream	aStream 		nextPut: $<;		nextPutAll: placeholderName;		nextPut: $>! !!TeaPlaceholder methodsFor: 'initialization'!setPlaceholderName: aString typeConstraint: aTypeConstraint	placeholderName := aString asSymbol.	typeConstraint := aTypeConstraint.	^ self! !!TeaPlaceholderStop methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	| match |	match := urlSegments size = 1 		and: [ urlSegments first ~= TeaPadding 		and: [ (typeConstraint matchesTo: urlSegments first) ] ].	match ifTrue:		 [ aDictionary			at: placeholderName 			put: (typeConstraint parseString: urlSegments first) ].	^ match! !!TeaWildcard class methodsFor: 'instance creation'!atLast: aBoolean	^ aBoolean		ifTrue: [ TeaWildcardStop new ]		ifFalse: [ TeaWildcard new ]! !!TeaWildcard methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaWildcard methodsFor: 'printing'!printOn: aStream	aStream nextPut: $*! !!TeaWildcardStop methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ true! !!TeaMethodMatcher class methodsFor: 'instance creation'!any	^ self new 		setMatcherBlock: [ :anyMethod | true ] 		name: 'ANY'! !!TeaMethodMatcher class methodsFor: 'instance creation'!exactly: aSymbol	^ self new 		setMatcherBlock: [ :actual | actual = aSymbol ] 		name: aSymbol asString! !!TeaMethodMatcher methodsFor: 'converting'!asString	^ name! !!TeaMethodMatcher methodsFor: 'http method matcher'!matchesHttpMethod: aSymbol	^ matcherBlock value: aSymbol! !!TeaMethodMatcher methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: name;		nextPut: $:! !!TeaMethodMatcher methodsFor: 'initialization'!setMatcherBlock: aBlockClosure name: aString	matcherBlock := aBlockClosure.	name := aString.	^ self! !!Tea405AwareNotFoundHandler methodsFor: 'private'!populateAllowedHeaderOf: response withAllowedRoutes: allowedRoutes	allowedRoutes do: [ :route | 		response headers 			at: 'Allow' 			put: route methodMatcher asString			ifPresentMerge: [ :old :new | old, ', ', new ] ].	^ response! !!Tea405AwareNotFoundHandler methodsFor: 'not found handler'!requestNotFound: aZnRequest	| allowedRoutes |	allowedRoutes := routes		select: [ :each | each canHandleUrl: aZnRequest url ].	^ allowedRoutes		ifEmpty: [ ZnResponse notFound: aZnRequest url ]		ifNotEmpty: [			self				populateAllowedHeaderOf: (ZnResponse methodNotAllowed: aZnRequest)				withAllowedRoutes: allowedRoutes ]! !!TeaNotFoundHandler methodsFor: 'initialization'!initialize	super initialize.	routes := OrderedCollection new.! !!TeaNotFoundHandler methodsFor: 'initialization'!initializeRoutes: aTeaRouteCollection	routes := aTeaRouteCollection.	^ self! !!TeaNotFoundHandler methodsFor: 'not found handler'!requestNotFound: aZnRequest	^ ZnResponse notFound: aZnRequest url! !!TeaOutput class methodsFor: 'response transformers'!html	^ self stringWithContentType: ZnMimeType textHtml! !!TeaOutput class methodsFor: 'response transformers'!json	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #NeoJSONWriter) toString: aTeaResponse body) 			type: (ZnMimeType applicationJson charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!mustache: templateStringOrStream contentType: contentType	^ [ :aTeaResponse | | model object entity |		object := aTeaResponse body.		model := (object respondsTo: #asDictionary) ifTrue: [ object asDictionary ] ifFalse: [ object ].				entity := (ZnStringEntity 			with: (((self optionalClass: #MustacheTemplate) on: templateStringOrStream) value: model) 			type: contentType).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!mustacheHtml: templateString 	^ self mustache: templateString contentType: ZnMimeType textHtml.! !!TeaOutput class methodsFor: 'private'!optionalClass: aSymbol	[ ^ Smalltalk at: aSymbol ]		on: KeyNotFound		do: [ self error: 'An optional dependency ', aSymbol, ' was not found. Please load it first.' ]! !!TeaOutput class methodsFor: 'response transformers'!ston	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #STON) toString: aTeaResponse body) 			type: (ZnMimeType textPlain charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!stream	^ self stream: ZnMimeType applicationOctetStream ! !!TeaOutput class methodsFor: 'response transformers'!stream: aZnMimeType	^ [ :aTeaResponse | | entity |		entity := ZnStreamingEntity 			readFrom: aTeaResponse body			usingType: aZnMimeType			andLength: aTeaResponse body size.		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!stringWithContentType: aZnMimeType 	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity new			contentType: (aZnMimeType charSet: aTeaResponse charSet; yourself);			string: aTeaResponse body asString;			yourself.		self 			znEntity: entity 			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!text	^ self stringWithContentType: ZnMimeType textPlain! !!TeaOutput class methodsFor: 'private'!znEntity: aZnEntity code: anInteger headers: aDictionary	| headers |	headers := ZnHeaders defaultResponseHeaders.	headers addAll: aDictionary.	^ ZnResponse new		statusLine: (ZnStatusLine code: anInteger);		headers: headers;		entity: aZnEntity;		yourself! !!TeaRequest class methodsFor: 'instance creation'!fromZnRequest: aZnRequest	^ self fromZnRequest: aZnRequest pathParams: Dictionary new! !!TeaRequest class methodsFor: 'instance creation'!fromZnRequest: aZnRequest pathParams: aDictionary	^ self new setZnRequest: aZnRequest pathParams: aDictionary! !!TeaRequest methodsFor: 'aborting'!abort: response	(TeaAbort response: response) signal! !!TeaRequest methodsFor: 'acccessing - params'!at: aSymbol	^ self 		at: aSymbol 		ifAbsent: [ TeaNoSuchParam signalWithParam: aSymbol ]! !!TeaRequest methodsFor: 'acccessing - params'!at: aSymbol ifAbsent: aBlock	"Gets the value of a path parameter, query parameter for form parameter.		E.g. /foo/<path-param>/bar		E.g. /foo?queryParam=value"	^ pathParams at: aSymbol ifAbsent: [ self queryOrFormParam: aSymbol ifAbsent: aBlock	"XXX do something better" ]! !!TeaRequest methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	^ aMessage sendTo: znRequest! !!TeaRequest methodsFor: 'private'!formParam: aSymbol ifAbsent: aBlock	^ (znRequest entity isKindOf: ZnApplicationFormUrlEncodedEntity) "XXX do something better" 		ifTrue: [ znRequest entity at: aSymbol ifAbsent: aBlock ]		ifFalse: aBlock! !!TeaRequest methodsFor: 'private'!queryOrFormParam: aSymbol ifAbsent: aBlock	^ znRequest uri 		queryAt: aSymbol 		ifAbsent: [ self formParam: aSymbol ifAbsent: aBlock ]! !!TeaRequest methodsFor: 'initialization'!setZnRequest: aZnRequest pathParams: aDictionary	znRequest := aZnRequest.	pathParams := aDictionary.	^ self! !!TeaRequestMatcher class methodsFor: 'instance creation'!method: aMethodMatcher url: anUrlPattern	^ self new setPattern: anUrlPattern method: aMethodMatcher! !!TeaRequestMatcher methodsFor: 'request matcher'!matchRequest: aZnRequest ifMatch: matchBlock ifNoMatch: noMatchBlock	| placeholders matches |	(methodMatcher matchesHttpMethod: aZnRequest method) ifFalse: [ ^ noMatchBlock value ].	placeholders := Dictionary new.	matches := (urlPattern matchesUrl: aZnRequest url placeholders: placeholders) 		and: [ whenClause cull: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders) ].	^ matches 		ifTrue: [ matchBlock value: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders) ]		ifFalse: noMatchBlock! !!TeaRequestMatcher methodsFor: 'request matcher'!matchesUrl: aZnUrl	^ urlPattern matchesUrl: aZnUrl placeholders: Dictionary new! !!TeaRequestMatcher methodsFor: 'accessing'!methodMatcher	^ methodMatcher! !!TeaRequestMatcher methodsFor: 'printing'!printOn: aStream	methodMatcher printOn: aStream.	aStream space.	urlPattern printOn: aStream.! !!TeaRequestMatcher methodsFor: 'initialization'!setPattern: anUrlPattern method: aMethodMatcher	urlPattern := anUrlPattern.	methodMatcher := aMethodMatcher.	whenClause := [ :anyRequest | true ].	^ self! !!TeaRequestMatcher methodsFor: 'accessing'!whenClause: aBlockClosure 	whenClause := aBlockClosure! !!TeaResponse class methodsFor: 'instance creation'!badRequest	^ self code: ZnStatusLine badRequest code! !!TeaResponse class methodsFor: 'instance creation'!code: anInteger	^ self new code: anInteger! !!TeaResponse class methodsFor: 'instance creation'!created	^ self code: ZnStatusLine created code! !!TeaResponse class methodsFor: 'instance creation'!methodNotAllowed	^ self code: ZnStatusLine methodNotAllowed code ! !!TeaResponse class methodsFor: 'instance creation'!notFound	^ self code: ZnStatusLine notFound code ! !!TeaResponse class methodsFor: 'instance creation'!notModified	^ self code: ZnStatusLine notModified code! !!TeaResponse class methodsFor: 'instance creation'!ok	^ self code: ZnStatusLine ok code! !!TeaResponse class methodsFor: 'instance creation'!redirect	^ self code: ZnStatusLine redirect code! !!TeaResponse class methodsFor: 'instance creation'!serverError	^ self code: ZnStatusLine internalServerError code! !!TeaResponse class methodsFor: 'instance creation'!unauthorized	^ self code: ZnStatusLine unauthorized code! !!TeaResponse methodsFor: 'accessing'!body	^ body! !!TeaResponse methodsFor: 'accessing'!body: anObject	body := anObject.	^ self! !!TeaResponse methodsFor: 'accessing'!charSet	^ charSet! !!TeaResponse methodsFor: 'accessing'!charSet: aString	charSet := aString.	^ self! !!TeaResponse methodsFor: 'accessing'!code	^ code! !!TeaResponse methodsFor: 'accessing'!code: anInteger	code := anInteger.	^ self! !!TeaResponse methodsFor: 'accessing'!headerName: nameString value: valueString	headers at: nameString put: valueString.	^ self! !!TeaResponse methodsFor: 'accessing'!headers	^ headers! !!TeaResponse methodsFor: 'accessing'!headers: aDictionary	headers := aDictionary asDictionary.	^ self! !!TeaResponse methodsFor: 'initialization'!initialize	super initialize.	headers := Dictionary new.	body := String crlf.	code := ZnStatusLine ok code.	charSet := 'utf-8'.! !!TeaResponse methodsFor: 'accessing'!location: url	self headerName: 'Location' value: url asString.	^ self! !!TeaResponse methodsFor: 'response transforming'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: self cull: aTeaRequest! !!TeaRoute class methodsFor: 'instance creation'!matcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	^ self new 		setMatcher: aTeaRequestMatcher		action: aTeaAction		transformer: aResponseTransformer		port: portNumber "XXX only used by teapsoon inspector"! !!TeaRoute methodsFor: 'request handling'!canHandleUrl: aZnUrl	"only check the URL not without checking HTTP Method or when clause"	^ requestMatcher matchesUrl: aZnUrl! !!TeaRoute methodsFor: 'request handling'!handleRequest: aZnRequest ifUnhandled: aBlock	^ requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest |			(action teaEvalActionOnRequest: aTeaRequest)				teaTransform: responseTransformer				request: aTeaRequest ]		ifNoMatch: aBlock! !!TeaRoute methodsFor: 'accessing'!methodMatcher 	^ requestMatcher methodMatcher ! !!TeaRoute methodsFor: 'printing'!printOn: aStream	requestMatcher printOn: aStream.	aStream nextPutAll: ' -> '.	action printOn: aStream.! !!TeaRoute methodsFor: 'accessing'!responseTransformer: aBlock	responseTransformer := aBlock! !!TeaRoute methodsFor: 'initialization'!setMatcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	responseTransformer := aResponseTransformer.	port := portNumber.	^ self! !!TeaRoute methodsFor: 'accessing'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure! !!TeaCompositeRouter class methodsFor: 'instance creation'!routers: teaRouterCollection	^ self new setRouters: teaRouterCollection! !!TeaCompositeRouter methodsFor: 'filters'!addAfterFilter: aTeaFilter	^ afterFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'filters'!addBeforeFilter: aTeaFilter	^ beforeFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'error handing'!addErrorHandler: aTeaErrorHandler	^ errorhandlers add: aTeaErrorHandler! !!TeaCompositeRouter methodsFor: 'accessing'!afterFilters	^afterFilters ! !!TeaCompositeRouter methodsFor: 'accessing'!beforeFilters	^beforeFilters ! !!TeaCompositeRouter methodsFor: 'private'!evaluateAfterFilters: aZnRequest response: aZnResponse	afterFilters do: [ :each | each handleRequest: aZnRequest response: aZnResponse ]! !!TeaCompositeRouter methodsFor: 'private'!evaluateBeforeFilters: aZnRequest	beforeFilters do: [ :each | each handleRequest: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'private'!evaluateRouters: aZnRequest ifUnhandled: aBlock	routers do: [ :each | | response |		response := each handleRequest: aZnRequest ifUnhandled: nil.		response ifNotNil: [ ^ response ] ].	^ aBlock value! !!TeaCompositeRouter methodsFor: 'private'!exceptionOccurred: anException request: aZnRequest	| handler |	handler := errorhandlers 		detect: [ :each | each canHandleError: anException ]		ifNone: [ anException pass ].			^ handler handleError: anException request: (TeaRequest fromZnRequest: aZnRequest).	! !!TeaCompositeRouter methodsFor: 'zn delegate'!handleRequest: aZnRequest	^ self 		handleRequest: aZnRequest 		ifUnhandled: [ notFoundHandler requestNotFound: aZnRequest ] ! !!TeaCompositeRouter methodsFor: 'zn delegate'!handleRequest: aZnRequest ifUnhandled: aBlock	| response |	^ [ self evaluateBeforeFilters: aZnRequest.	     response := self evaluateRouters: aZnRequest ifUnhandled: aBlock.	     self evaluateAfterFilters: aZnRequest response: response.	     response		   ] on: Exception 	     do: [ :ex | self exceptionOccurred: ex request: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'initialization'!initialize	super initialize.	errorhandlers := OrderedCollection new.	beforeFilters := OrderedCollection new.	afterFilters := OrderedCollection new.	notFoundHandler := TeaNotFoundHandler new.! !!TeaCompositeRouter methodsFor: 'error handing'!notFoundHandler: aTeaNotFoundHandler	notFoundHandler := aTeaNotFoundHandler! !!TeaCompositeRouter methodsFor: 'initialization'!setRouters: teaRouterCollection	routers := teaRouterCollection asArray.	^ self! !!TeaDynamicRouter methodsFor: 'route dispatcher'!addRoute: aRoute	^ routes add: aRoute! !!TeaDynamicRouter methodsFor: 'zn delegate'!handleRequest: aZnRequest ifUnhandled: aBlock	routes do: [ :each | | response |		response := each handleRequest: aZnRequest ifUnhandled: nil.		response ifNotNil: [ ^ response ] ].	^ aBlock value! !!TeaDynamicRouter methodsFor: 'initialization'!initialize	super initialize.	routes := OrderedCollection new.! !!TeaDynamicRouter methodsFor: 'accessing'!routes	^routes! !!TeaRouter methodsFor: 'router'!handleRequest: aZnRequest ifUnhandled: aBlock	self subclassResponsibility ! !!TeaStaticRouter methodsFor: 'zn delegate'!handleRequest: aZnRequest ifUnhandled: aBlock	| response |	delegate ifNil: [ ^ aBlock value ].	response := delegate handleRequest: aZnRequest.	^ response isNotFound ifTrue: aBlock ifFalse: [ response ]! !!TeaStaticRouter methodsFor: 'acccessing'!urlPrefix: urlPrefixString path: pathString	delegate ifNil: [ delegate := ZnStaticFileServerDelegate new ].	delegate		prefixFromString: urlPrefixString;		directory: pathString asFileReference.! !!TeaGlobUrlPattern class methodsFor: 'private'!createSegment: aString atLast: aBoolean	aString = '*' 		ifTrue: [ ^ TeaWildcard atLast: aBoolean ].	(aString beginsWith: '<')		ifTrue: [ ^ TeaPlaceholder fromString: aString atLast: aBoolean ].	^ TeaLiteral fromString: aString atLast: aBoolean! !!TeaGlobUrlPattern class methodsFor: 'private'!parseSegments: aString	| tokens |	tokens := aString findTokens: '/'.	^ tokens collectWithIndex: [ :each :idx | 		self createSegment: each atLast: idx = tokens size ]! !!TeaGlobUrlPattern class methodsFor: 'instance creation'!parseString: aString	^ self new setSegments: (self parseSegments: aString)! !!TeaGlobUrlPattern methodsFor: 'url matcher'!matchesUrl: anUrl placeholders: aDictionary	| urlSegments |	urlSegments := self padUrlSegments: anUrl with: TeaPadding size: segments size.	segments isEmpty		ifTrue: [ ^ urlSegments isEmpty ].	^ segments first 		matches: urlSegments 		rest: segments allButFirst 		placeholders: aDictionary! !!TeaGlobUrlPattern methodsFor: 'private'!padUrlSegments: anUrl with: padding size: anInteger	| urlSegments |	urlSegments := anUrl segments isEmptyOrNil 		ifTrue: [ OrderedCollection new ]		ifFalse: [ self trimTrailingSlash: anUrl segments ].	urlSegments size < segments size		ifTrue: [ urlSegments := urlSegments forceTo: anInteger paddingWith: padding ].	^ urlSegments! !!TeaGlobUrlPattern methodsFor: 'printing'!printOn: aStream	aStream nextPut: $'.	segments 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $/ ].	aStream nextPut: $'.! !!TeaGlobUrlPattern methodsFor: 'initialization'!setSegments: anArray	segments := anArray.	^ self! !!TeaGlobUrlPattern methodsFor: 'private'!trimTrailingSlash: urlSegments 	^ (urlSegments isNotEmpty and: [ urlSegments last = '/' ])		ifTrue: [ urlSegments allButLast ]		ifFalse: [ urlSegments ]! !!TeaRxUrlPattern class methodsFor: 'instance creation'!fromRxMatcher: aRxMatcher 	^ self new initializeRxMatcher: aRxMatcher ! !!TeaRxUrlPattern methodsFor: 'private'!hasMatched: aZnUrl	"XXX RxMatcher has state. Consider something better"	^ lock critical: [ (regexp matches: aZnUrl path) or: [ regexp matches: '/', aZnUrl path ] ]! !!TeaRxUrlPattern methodsFor: 'initialization'!initializeRxMatcher: aRxMatcher 	regexp := aRxMatcher.	lock := Mutex new.	^ self! !!TeaRxUrlPattern methodsFor: 'url matcher'!matchesUrl: aZnUrl placeholders: aDictionary 	| match |	match := self hasMatched: aZnUrl.	match ifTrue:		[ 2 to: regexp subexpressionCount do: [ :i | 			aDictionary at: i - 1put: (regexp subexpression: i) ] ].	^ match! !!TeaRxUrlPattern methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: '<regexp>'.! !!TeaUrlPattern methodsFor: 'url matcher'!matchesUrl: anUrl placeholders: aDictionary	self subclassResponsibility ! !!TeaUrlPatternSet class methodsFor: 'instance creation'!fromCollection: aCollection 	^ self new setPatterns: (aCollection collect: #asTeaUrlPattern)! !!TeaUrlPatternSet methodsFor: 'url matcher'!matchesUrl: anUrl placeholders: aDictionary	^ patterns anySatisfy: [ :each | each matchesUrl: anUrl placeholders: aDictionary ]! !!TeaUrlPatternSet methodsFor: 'printing'!printOn: aStream	aStream nextPut: ${.	patterns 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $. ].	aStream nextPut: $}.! !!TeaUrlPatternSet methodsFor: 'initialization'!setPatterns: aCollection 	patterns := aCollection.	^ self! !!Teapot class methodsFor: 'instance creation'!configure: optionsAssociations	"Create a new Teapot instance with optional properties. 	 - Teapot properties: #defaultOutput, #znServer	 - ZnServer properties: See options protocol of ZnServer for specific usages.		Example: Teapot configure: { 		#defaultOutput -> #json. 		#bindAddress -> #[192 168 0 3].		#port -> 8080. 		#debugMode -> true.		#notFoundHandlerClass -> Tea405AwareNotFoundHandler.	}."		^ self new initializeOptions: optionsAssociations asDictionary! !!Teapot class methodsFor: 'instance creation'!on	"Create Teapot with default properties."		^ self configure: { }! !!Teapot class methodsFor: 'controlling'!stopAll	self allInstancesDo: #stop! !!Teapot methodsFor: 'url mapping'!CONNECT: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #CONNECT)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!DELETE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #DELETE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!GET: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #GET) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!HEAD: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #HEAD) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!OPTIONS: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #OPTIONS)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!PATCH: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #PATCH)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!POST: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #POST) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!PUT: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #PUT) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!TRACE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #TRACE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'private'!addRouteMethod: aTeaMethodMatcher pattern: pattern action: aTeaAction	current := dynamicRouter addRoute:		(TeaRoute			matcher: (TeaRequestMatcher method: aTeaMethodMatcher url: pattern asTeaUrlPattern)			action: aTeaAction			transformer: defaultOutput			port: server port)! !!Teapot methodsFor: 'filters'!after: patternActionAssoc	current := compositeRouter addAfterFilter:				(TeaAfterFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping'!any: patternActionAssoc	self		addRouteMethod: TeaMethodMatcher any		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'filters'!before: patternActionAssoc	current := compositeRouter addBeforeFilter:				(TeaBeforeFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping'!exception: anExceptionSetActionAssoc	current := compositeRouter addErrorHandler:		(TeaErrorHandler			for: anExceptionSetActionAssoc key			action: anExceptionSetActionAssoc value			responseTransformer: defaultOutput)! !!Teapot methodsFor: 'initialization'!initializeOptions: optionsDictionary	dynamicRouter := TeaDynamicRouter new.	staticRouter := TeaStaticRouter new.	compositeRouter := TeaCompositeRouter routers: {dynamicRouter. staticRouter}.		defaultOutput := self responseTransformer: (optionsDictionary at: #defaultOutput ifAbsent: #html).										self exception: TeaAbort -> [ :abort :req | abort response teaTransform: [ :same | same ] request: req].	server := optionsDictionary 		at: #znServer		ifAbsent: [ ZnServer defaultServerClass new ].	optionsDictionary 		at: #notFoundHandlerClass 		ifPresent: [:class | compositeRouter notFoundHandler: (class new initializeRoutes: dynamicRouter routes)].	server delegate: compositeRouter.		optionsDictionary keysAndValuesDo: [ :key :value | server optionAt: key put: value ].	^ self! !!Teapot methodsFor: 'url mapping'!output: transformerBlockOrSymbol	current responseTransformer: (self responseTransformer: transformerBlockOrSymbol)	! !!Teapot methodsFor: 'private'!responseTransformer: transformerBlockOrSymbol	^ transformerBlockOrSymbol isSymbol		ifTrue: [ TeaOutput perform: transformerBlockOrSymbol ]		ifFalse: [ transformerBlockOrSymbol ]! !!Teapot methodsFor: 'url mapping'!serveStatic: urlPrefixString from: pathString		staticRouter urlPrefix: urlPrefixString path: pathString! !!Teapot methodsFor: 'accessing'!server	^ server! !!Teapot methodsFor: 'controlling'!start	server start! !!Teapot methodsFor: 'controlling'!stop	server stop! !!Teapot methodsFor: 'filters'!when: aBlockClosure 	current whenClause: aBlockClosure	! !!Collection methodsFor: '*Teapot-Core'!asTeaUrlPattern	^ TeaUrlPatternSet fromCollection: self! !"Teapot-Core"!!TeaTestClient commentStamp: '' prior: 0!Http client for testing.!!TeaUrlPatternTest methodsFor: 'private'!pattern: patternString matches: urlString	| placeholders |	placeholders := Dictionary new.	self assert: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'private'!pattern: patternString noMatch: urlString	| placeholders |	placeholders := Dictionary new.	self deny: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'tests'!testLongerPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests'!testLongerPatternEndedWildcard	self pattern: '/a/b/c/*' matches: '/a/b/c'.	self pattern: '/1/2/3/*/*' matches: '/1/2/3'.		self pattern: '/a/b/c/*' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests'!testNoWildcard		self pattern: '/aa' matches: '/aa'.	self pattern: '/aa' noMatch: '/bb'.! !!TeaUrlPatternTest methodsFor: 'tests'!testPlaceholderSubstitute	| placeholders |		placeholders := self pattern: '/<id>/a/b' matches: '/123/a/b'.	self assert: (placeholders at: #id) equals: '123'.		placeholders := self pattern: '/a/<id>/b' matches: '/a/25/b'.	self assert: (placeholders at: #id) equals: '25'.		placeholders := self pattern: '/a/b/<id>' matches: '/a/b/xyz'.		self assert: (placeholders at: #id) equals: 'xyz'.		! !!TeaUrlPatternTest methodsFor: 'tests'!testPlaceholderTypeMatch	| placeholders |	placeholders := self pattern: '/<id:IsInteger>' matches: '/12'.	self assert: (placeholders at: #id) equals: 12.		placeholders := self pattern: '/<id:IsInteger>/abc' matches: '/-34/abc'.	self assert: (placeholders at: #id) equals: -34.		placeholders := self pattern: '/<float:IsNumber>/<int:IsNumber>' matches: '/3.14/3'.	self assert: (placeholders at: #float) equals: 3.14.	self assert: (placeholders at: #int) equals: 3.	! !!TeaUrlPatternTest methodsFor: 'tests'!testPlaceholderTypeNoMatch	self pattern: '/<id:IsInteger>' noMatch: '/foobar'.		self pattern: '/<id:IsNumber>' noMatch: '/foobar'.	self pattern: '/<id:IsInteger>' noMatch: '/12.3'.		! !!TeaUrlPatternTest methodsFor: 'tests'!testPlaceholders	self pattern: '/<id>/a/b' matches: '/1/a/b'.	self pattern: '/a/<id>/b' matches: '/a/2/b'.	self pattern: '/a/b/<id>' matches: '/a/b/1'.			self pattern: '/<id>/a/b' noMatch: '/1/a/c'.	self pattern: '/a/<id>/b' noMatch: '/a/2/c'.	self pattern: '/a/b/<id>' noMatch: '/a/c/1'.! !!TeaUrlPatternTest methodsFor: 'tests'!testRoot	self pattern: '/' matches: '/'.		self pattern: '/' noMatch: '/a'.		self pattern: '/a' noMatch: '/'.	self pattern: '/a/b' noMatch: '/'.	! !!TeaUrlPatternTest methodsFor: 'tests'!testShorterPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b/1/2'.	! !!TeaUrlPatternTest methodsFor: 'tests'!testShorterPatternEndedWildcard	 	self pattern: '/a/*' matches: '/a/b/c'.	self pattern: '/*' matches: '/1/2/3'.	 	self pattern: '/a/*' noMatch: '/b/b/c'.	self pattern: '/a/b' noMatch: '/a/b/c'.	! !!TeaUrlPatternTest methodsFor: 'tests'!testTralingSlash	self pattern: '/a/b' matches: '/a/b/'.! !!TeaUrlPatternTest methodsFor: 'tests'!testWildcards	self pattern: '/*/1/2' matches: '/0/1/2'.	self pattern: '/a/b/*' matches: '/a/b/c'.	self pattern: '/x/*/z' matches: '/x/y/z'.		self pattern: '/*/1/2' noMatch: '/a/1/z'.		self pattern: '/a/b/*' noMatch: '/a/1/z'.		self pattern: '/x/*/z' noMatch: '/a/1/z'.						! !!TeapotAbortTest methodsFor: 'running'!setUp	server := Teapot on		GET: 'badrequest' -> [ :req | req abort: (ZnResponse badRequest: req) ];		GET: 'unauthorized' -> [ :req | req abort: TeaResponse unauthorized ];		GET: 'abortstring' -> [ :req | req abort: 'abort test' ];				start.! !!TeapotAbortTest methodsFor: 'running'!tearDown	server stop! !!TeapotAbortTest methodsFor: 'tests'!testAbortSupportsAnyObject	self assert: (TeaTestClient httpGetString: '/abortstring') equals: 'abort test'.! !!TeapotAbortTest methodsFor: 'tests'!testErrorCodes	self assert: (TeaTestClient httpGet: '/badrequest') code equals: 400.	self assert: (TeaTestClient httpGet: '/unauthorized') code equals: 401.! !!TeapotAfterTest methodsFor: 'running'!setUp	server := Teapot on		after: '/after/<param>' -> [ :req :resp | resp headers at: 'header-key' put: (req at: #param) ];		GET: '/after/*' -> 'after-return';				start		! !!TeapotAfterTest methodsFor: 'running'!tearDown	server stop! !!TeapotAfterTest methodsFor: 'tests'!testAfterFilterCanModifyResponse	| response |		response := TeaTestClient httpGet: '/after/header-value'.	self assert: response entity string equals: 'after-return'.	self assert: (response headers at: 'header-key') equals: 'header-value'.		response := TeaTestClient httpPost: '/after/notfound'.	self assert: response code equals: 404.	self assert: (response headers at: 'header-key') equals: 'notfound'.! !!TeapotBeforeTest methodsFor: 'private'!forbidden	^ ZnResponse new		statusLine: ZnStatusLine forbidden;		headers: ZnHeaders defaultResponseHeaders;		yourself! !!TeapotBeforeTest methodsFor: 'private'!logRequest: aTeaRequest	log add: (aTeaRequest at: #user)! !!TeapotBeforeTest methodsFor: 'running'!setUp	log := OrderedCollection new.	server := Teapot on		before: '/secure/*' -> [ :req | ((req at: #user) = 'admin' and: [ (req at: #pass) = '****' ]) 			ifFalse: [ req abort: self forbidden ] ];		before: '*' -> (Send message: #logRequest: to: self);		before: '*' -> 'any';		GET: '/secure' -> 'protected';		GET: '/secure/1/2/3' -> 'protected';		POST: '/public' -> 'public';		start		! !!TeapotBeforeTest methodsFor: 'running'!tearDown	server stop! !!TeapotBeforeTest methodsFor: 'tests'!testAuthentication	self assert: (TeaTestClient httpGetString: '/secure?user=admin&pass=****') equals: 'protected'.	self assert: (TeaTestClient httpGetString: '/secure/1/2/3?user=admin&pass=****') equals: 'protected'.			self assert: (TeaTestClient httpGet: '/secure?user=user01&pass=****') code equals: 403.	self assert: (TeaTestClient httpGet: '/secure/1/2/3?user=user02&pass=****') code equals: 403.			self assert: (TeaTestClient httpPostString: '/public?user=any') equals: 'public'.! !!TeapotBeforeTest methodsFor: 'tests'!testMultipleBeforeHandlers	TeaTestClient httpGet: '/secure?user=admin&pass=****'.	TeaTestClient httpGet: '/secure/1/2/3?user=admin&pass=****'.		TeaTestClient httpGet: '/secure?user=user01&pass=****'. "403 before second filter"	TeaTestClient httpPost: '/public?user=pubuser'.					self assert: log asArray equals: #(admin admin pubuser).! !!TeapotDefaultFormatTest methodsFor: 'running'!setUp	server := (Teapot configure: { #defaultOutput -> #text })		GET: 'default' -> 'any';		GET: 'html' -> 'any'; output: #html;		start		! !!TeapotDefaultFormatTest methodsFor: 'running'!tearDown	server stop! !!TeapotDefaultFormatTest methodsFor: 'tests'!testDefault	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textPlain! !!TeapotDefaultFormatTest methodsFor: 'tests'!testOverride	self 		assert: (TeaTestClient httpGet: '/html') contentType 		equals: ZnMimeType textHtml! !!TeapotEncodingTest methodsFor: 'running'!setUp	server := Teapot on		GET: 'enc' -> (TeaResponse ok 								body: 'rvztr tkrfrgp'; 								charSet: 'iso-8859-2');		start! !!TeapotEncodingTest methodsFor: 'running'!tearDown	server stop! !!TeapotEncodingTest methodsFor: 'tests'!testUserSpecifiedEncoding	| response |	response := TeaTestClient httpGet: '/enc'.	self 		assert: response entity string		equals: 'rvztr tkrfrgp'.			self 		assert: response contentType charSet		equals: 'iso-8859-2'! !!TeapotErrorHandlingTest methodsFor: 'private'!handleError: ex request: req	self assert: (ex isKindOf: Exception).	self assert: (req isKindOf: TeaRequest).	^ ZnResponse ok: (ZnStringEntity text: 'outofbounds/domainerror handled')! !!TeapotErrorHandlingTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/zerodiv' -> [ 1 / 0 ];		GET: '/sub' -> [ #() at: 123 ];					GET: '/domain' -> [ -2 sqrt ];		GET: '/nonbool' -> [ NotYetImplemented signal ];		GET: '/keynotfound' -> [ KeyNotFound signal ];		exception: ZeroDivide -> [ :ex :req | 'zerodiv handled' ];		exception: SubscriptOutOfBounds, DomainError -> (Send message: #handleError:request: to: self);		exception: NotYetImplemented -> (ZnResponse ok: (ZnStringEntity text: 'nonbool handled'));		exception: KeyNotFound -> 42;		output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		start		! !!TeapotErrorHandlingTest methodsFor: 'running'!tearDown	server stop! !!TeapotErrorHandlingTest methodsFor: 'tests'!testHandlesExceptionSet	self assert: (TeaTestClient httpGetString: '/sub') equals: 'outofbounds/domainerror handled'.		self assert: (TeaTestClient httpGetString: '/domain') equals: 'outofbounds/domainerror handled'.		! !!TeapotErrorHandlingTest methodsFor: 'tests'!testHandlesOneException	self assert: (TeaTestClient httpGetString: '/zerodiv') equals: 'zerodiv handled'.	! !!TeapotErrorHandlingTest methodsFor: 'tests'!testTransformingErroHandlerResponse	self assert: (TeaTestClient httpGetString: '/keynotfound') equals: 'XLII'.! !!TeapotErrorHandlingTest methodsFor: 'tests'!testValueAsExceptionHandler	self assert: (TeaTestClient httpGetString: '/nonbool') equals: 'nonbool handled'.	! !!TeapotFormParamsTest methodsFor: 'running'!setUp	server := Teapot on		POST: '/form' -> [ :req | (req at: #foo), '-', (req at: #bar) ];		exception: TeaNoSuchParam -> 'no such param';		start.! !!TeapotFormParamsTest methodsFor: 'running'!tearDown	server stop! !!TeapotFormParamsTest methodsFor: 'tests'!testFormParams	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'foo' put: 'abc'; 		at: 'bar' put: '123'; 		yourself).	self assert: result entity string equals: 'abc-123'.! !!TeapotFormParamsTest methodsFor: 'tests'!testFormParamsNotFound	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'invalid1' put: 'abc'; 		at: 'invalid2' put: '123'; 		yourself).	self assert: result entity string equals: 'no such param'! !!TeapotFormatTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/a' -> [ 4 ]; output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		GET: 'default' -> 'any';		GET: '/plain' -> 'any'; output: #text;		GET: 'xml' -> 'any'; output: (TeaOutput stringWithContentType: ZnMimeType applicationXml);		start		! !!TeapotFormatTest methodsFor: 'running'!tearDown	server stop! !!TeapotFormatTest methodsFor: 'tests'!testArbitraryContentType	self 		assert: (TeaTestClient httpGet: '/xml') contentType 		equals: (ZnMimeType applicationXml charSet: 'utf-8'; yourself)! !!TeapotFormatTest methodsFor: 'tests'!testConverting	self assert: (TeaTestClient httpGetString: '/a') equals: 'IV'.	! !!TeapotFormatTest methodsFor: 'tests'!testDefaultContentTypeIsHtml	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textHtml! !!TeapotFormatTest methodsFor: 'tests'!testSetsContentType	self 		assert: (TeaTestClient httpGet: '/plain') contentType 		equals: ZnMimeType textPlain! !!TeapotMessageSendTest methodsFor: 'web controller'!msg1	^ 'msg1 result'! !!TeapotMessageSendTest methodsFor: 'web controller'!msg2Req: req nil: resp	self assert: resp isNil.	^ 'msg2 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'web controller'!msg3Req: req	^ 'msg3 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/msg1' -> (Send message: #msg1 to: self);		GET: '/msg2/<param>' -> (Send message: #msg2Req:nil: to: self);				GET: '/msg3/<param>' -> (Send message: #msg3Req: to: self);							start.		! !!TeapotMessageSendTest methodsFor: 'running'!tearDown	server stop! !!TeapotMessageSendTest methodsFor: 'tests'!testReceivingOneArgKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg3/bar') equals: 'msg3 bar'.! !!TeapotMessageSendTest methodsFor: 'tests'!testReceivingTwoArgsKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg2/foo') equals: 'msg2 foo'.! !!TeapotMessageSendTest methodsFor: 'tests'!testReceivingUnaryMessage	self assert: (TeaTestClient httpGetString: '/msg1') equals: 'msg1 result'.! !!TeapotPathParamTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/user/<id>' -> [ :req | '1-', (req at: #id) ];		GET: '/user/<id>/create' -> [ :req | '2-', (req at: #id) ];		GET: '/<id>/<user>' -> [ :req | '3-', (req at: #id) ];						POST: '/user/<id>/create' -> [ :req | '4-', (req at: #id) ];		start.		! !!TeapotPathParamTest methodsFor: 'running'!tearDown	server stop! !!TeapotPathParamTest methodsFor: 'tests'!testPlaceholderAtLast	self assert: (TeaTestClient httpGetString: '/user/12') equals: '1-12'	! !!TeapotPathParamTest methodsFor: 'tests'!testPlaceholderFirst	self assert: (TeaTestClient httpGetString: '/54/user') equals: '3-54'.	! !!TeapotPathParamTest methodsFor: 'tests'!testPlaceholderInside	self assert: (TeaTestClient httpGetString: '/user/34/create') equals: '2-34'.		! !!TeapotPathParamTest methodsFor: 'tests'!testPlaceholderPost	self assert: (TeaTestClient httpPostString: '/user/789/create') equals: '4-789'.		! !!TeapotQueryParamsTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/query' -> [ :req | req at: #foo ];		GET: '/queryopt' -> [ :req | req at: #foo ifAbsent: [ 'default' ] ];				start! !!TeapotQueryParamsTest methodsFor: 'running'!tearDown	server stop! !!TeapotQueryParamsTest methodsFor: 'tests'!testDefaultQueryParam	self assert: (TeaTestClient httpGetString: '/queryopt') equals: 'default'.	! !!TeapotQueryParamsTest methodsFor: 'tests'!testQueryParam	self assert: (TeaTestClient httpGetString: '/query?foo=bar') equals: 'bar'.	self assert: (TeaTestClient httpGetString: '/queryopt?foo=baz') equals: 'baz'.! !!TeapotRegexpTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/./' asRegex -> [ 'regexp' ];		GET: '\w+(\d)/\d/xxx' asRegex -> [ :req | req at: 1 ];		GET: '/(\d)/([abc]+)/\d/(.*)' asRegex -> [ :req | (req at: 1), (req at: 2), (req at: 3) ];				start! !!TeapotRegexpTest methodsFor: 'running'!tearDown	server stop! !!TeapotRegexpTest methodsFor: 'tests'!testCollectingSubexpressions	self assert: (TeaTestClient httpGetString: '/abc3/4/xxx') equals: '3'.		self assert: (TeaTestClient httpGetString: '/1/aabbcc/2/foobar') equals: '1aabbccfoobar'.! !!TeapotRegexpTest methodsFor: 'tests'!testIgnoresQueryParam	self assert: (TeaTestClient httpGetString: '/k/?param=value') equals: 'regexp'.	! !!TeapotRegexpTest methodsFor: 'tests'!testRegexpMatch	self assert: (TeaTestClient httpGetString: '/k/') equals: 'regexp'.	! !!TeapotResponseTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/test400' -> [ 			TeaResponse badRequest				body: 'malformed input';				headers: { 'my-header' -> 'my-value' } ];		start! !!TeapotResponseTest methodsFor: 'running'!tearDown	server stop! !!TeapotResponseTest methodsFor: 'tests'!testReturnsCustomCodeBodyAndHeaders	| response |	response := TeaTestClient httpGet: '/test400'.	self assert: response entity string equals: 'malformed input'.	self assert: response code equals: 400.	self assert: (response headers at: 'my-header') equals: 'my-value'.! !!TeapotReturnResponseTest methodsFor: 'running'!setUp	| stream |	stream := ZnStreamingEntity		readFrom: 'direct stream' readStream		usingType: ZnMimeType textHtml		andLength: 'direct stream' size.			server := Teapot on		GET: '/resp1' -> [ :req | ZnResponse ok: (ZnStringEntity text: 'direct response') ];		GET: '/resp2' -> (ZnResponse ok: stream);		GET: '/redirect' -> (ZnResponse redirect: '/redirect_location');		GET: '/redirect_location' -> 'redirected here';		start! !!TeapotReturnResponseTest methodsFor: 'running'!tearDown	server stop! !!TeapotReturnResponseTest methodsFor: 'tests'!testDirectStreamResponse	self assert: (TeaTestClient httpGetString: '/resp2') equals: 'direct stream'.	! !!TeapotReturnResponseTest methodsFor: 'tests'!testDirectStringResponse	self assert: (TeaTestClient httpGetString: '/resp1') equals: 'direct response'.	! !!TeapotReturnResponseTest methodsFor: 'tests'!testRedirect	self assert: (TeaTestClient httpGetString: '/redirect') equals: 'redirected here'.	! !!TeapotRouteSetTest methodsFor: 'running'!setUp	server := Teapot on		before: { '/secure/*' . '/protected/*' } -> [ :req | req abort: TeaResponse unauthorized ];			GET: {'/a'. '/b'. '/c'} -> 'abc';		POST: { '/x/<param>'. '/y/<param>' } -> [ :req | req at: #param ];		after: { '/a'. '/b' } -> [ :req :resp | resp headers at: 'test' put: 'ab' ];		start.! !!TeapotRouteSetTest methodsFor: 'running'!tearDown	server stop! !!TeapotRouteSetTest methodsFor: 'tests'!testMatchesAnyRouteInAfterFilter	| response |	response := TeaTestClient httpGet: '/a'.	self assert: (response headers at: 'test') equals: 'ab'.		response := TeaTestClient httpGet: '/b'.	self assert: (response headers at: 'test') equals: 'ab'.			response := TeaTestClient httpGet: '/c'.	self assert: (response headers at: 'test' ifAbsent: nil) equals: nil.! !!TeapotRouteSetTest methodsFor: 'tests'!testMatchesAnyRouteInBeforeFilter	| response |	response := TeaTestClient httpGet: '/secure/123'.	self assert: response code equals: 401.		response := TeaTestClient httpGet: '/protected/123'.	self assert: response code equals: 401.! !!TeapotRouteSetTest methodsFor: 'tests'!testMatchesAnyRouteInSet	self assert: (TeaTestClient httpGetString: '/a') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/b') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/c') equals: 'abc'.! !!TeapotRouteSetTest methodsFor: 'tests'!testMatchesAnyRouteInSetWithParams	self assert: (TeaTestClient httpPostString: '/x/value1') equals: 'value1'.	self assert: (TeaTestClient httpPostString: '/y/value2') equals: 'value2'.	! !!TeapotRoutingTest methodsFor: 'running'!setUp	| teapot |	teapot := Teapot configure: { #notFoundHandlerClass -> Tea405AwareNotFoundHandler }.	server := teapot		GET: '/' -> '1';		GET: '/a' -> '2';		POST: '/a' -> 'post';		GET: '/a/*/b' -> [ '3' ];		GET: '/*/c' -> [ '4' ];			GET: '/x/y/*' -> [ '5' ];		GET: '/x/*/*/z/*' -> [ '6' ];		GET: '/404' -> (ZnResponse notFound: '/custom');		any: 'any' -> 'any';		start.		! !!TeapotRoutingTest methodsFor: 'running'!tearDown	server stop! !!TeapotRoutingTest methodsFor: 'tests'!test404 	self assert: (TeaTestClient httpGet: '/1/2/3/4') code equals: 404! !!TeapotRoutingTest methodsFor: 'tests'!test405	| response |	response := TeaTestClient httpDelete: '/a'.	self assert: response code equals: 405.	self 		assert: (', ' split: (response headers at: 'Allow')) asSet		equals: #(GET POST) asSet.! !!TeapotRoutingTest methodsFor: 'tests'!testAnyMatchesToAnyHttpMethod 	self assert: (TeaTestClient httpGetString: '/any') equals: 'any'. 	self assert: (TeaTestClient httpPostString: '/any') equals: 'any'. 	self assert: (TeaTestClient httpPutString: '/any') equals: 'any'.	 	self assert: (TeaTestClient httpDeleteString: '/any') equals: 'any'.! !!TeapotRoutingTest methodsFor: 'tests'!testCustom404 	self assert: (TeaTestClient httpGetString: '/404') equals: 'Not Found /custom', String crlf! !!TeapotRoutingTest methodsFor: 'tests'!testMultipleWildcard	self assert: (TeaTestClient httpGetString: '/x/foo/bar/z/baz') equals: '6'.	self assert: (TeaTestClient httpGetString: '/x/foo/bar/z/baz/123') equals: '6'.	! !!TeapotRoutingTest methodsFor: 'tests'!testNoWildcard	self assert: (TeaTestClient httpGetString: '') equals: '1'.	self assert: (TeaTestClient httpGetString: '/a') equals: '2'.		! !!TeapotRoutingTest methodsFor: 'tests'!testWildcardEnd	self assert: (TeaTestClient httpGetString: '/x/y/foo') equals: '5'.		! !!TeapotRoutingTest methodsFor: 'tests'!testWildcardFirst	self assert: (TeaTestClient httpGetString: '/foo/c') equals: '4'	! !!TeapotRoutingTest methodsFor: 'tests'!testWildcardInside	self assert: (TeaTestClient httpGetString: '/a/bar/b') equals: '3'	! !!TeapotSslTest methodsFor: 'private'!pemContent	^ String streamContents: [ :stream | 		{'-----BEGIN CERTIFICATE-----'.'MIICAzCCAWwCCQDqdNQzO71rWzANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJB'.'VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0'.'cyBQdHkgTHRkMCAXDTE3MDYyNDA4MDM1OVoYDzIxMTcwNTMxMDgwMzU5WjBFMQsw'.'CQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu'.'ZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDk'.'ysKeTfdTjx0l573Ag4ITy80env0TfKGdyjlHkehuzQBQsg+DiyQs2Ckr9GaaZIOe'.'BW/6btvHG51aGG+Fz2WtHY4MetyLJ/zy5PlzjOeGvRwAUwla0JZX8fB8poKgNXkm'.'gVeuCA3PKPnE6Ba1ucofvdtIsDMqpbABLMxdjhvagQIDAQABMA0GCSqGSIb3DQEB'.'BQUAA4GBAEf6vsOCHtWJT760Wdm606TWpY+EbxKdXViEtWaDT0K91HBrGqBnSvgC'.'1ByDRKz1L3UyfUjgaP04Iuy3aAUtUZ188A4YfC1XLcYln3K/3NNP4+S272R09Nne'.'kV7vvJt4I8vubjEo3Ihassy4PVTwcf6JnUBIdK7p4k+yAupHjzof'.'-----END CERTIFICATE-----'.'-----BEGIN RSA PRIVATE KEY-----'.'MIICXQIBAAKBgQDkysKeTfdTjx0l573Ag4ITy80env0TfKGdyjlHkehuzQBQsg+D'.'iyQs2Ckr9GaaZIOeBW/6btvHG51aGG+Fz2WtHY4MetyLJ/zy5PlzjOeGvRwAUwla'.'0JZX8fB8poKgNXkmgVeuCA3PKPnE6Ba1ucofvdtIsDMqpbABLMxdjhvagQIDAQAB'.'AoGAG501XDIA1f8B/5820dONkaIZgcaiuQVj5E2SGEdODIGFtjenk7LpjNgSMBHx'.'iFT1Zc82Mr3KnP+CQGuOmlHr7XylvmFM29x/cLd4HSvZNdg6pMrzuv/ILC27GLfU'.'gDGAVmyeBiyMTOLk6TJ/LElIrt+HABaHaa43XH/mF3VjAoECQQDzc3aDXCOOBvlA'.'mV3TgMEIuP9vEq5dgdz7bYZSVutc605AYo/1c9TkmlMy722/abQm0IpT1XRNjTmc'.'HT+Y5gb5AkEA8JXcGS9T0L5Vl2cel9wiad5oNbLGfG17nQQUl3LXikfPrcBGDmD4'.'aoEZkScPx3gKfawwKw8wsUwus30aWZapyQJBAJ5IqftKQsuq+Q/pJznGcrsrHNio'.'urmNH5JRaY3LeYeWbfAqpRKfVwGy3Pk29pIHNdwupmFPXSi284fu9FSC6nECQQDV'.'w+IPwpyPcj7syuRE/ITbWpFvfQydjE30YqbFNnZLWKkv8hKNPh4by9/iuDlt+7we'.'k/ssl0+liVJJixP5nEP5AkB8dFXPvAsxeTHCPMwAsJlPnxRodktuY7SlEUqqEpex'.'yxwciD3/Fyai686sj5iYiOuy2xcxaFZvJ1K1J/aCvwhK'.'-----END RSA PRIVATE KEY-----'.} do: [ :line | stream nextPutAll: line; crlf ]]! !!TeapotSslTest methodsFor: 'private'!pemFile	^ FileLocator temp asFileReference / 'test-teapot-ssl.pem'! !!TeapotSslTest methodsFor: 'initialization'!setUp	self writeOutPemTo: self pemFile.	teapot := Teapot configure: { 		#znServer -> (			(ZnSecureServer on: 1443) 				certificate: self pemFile fullName;				yourself).	}.	teapot		GET: '/ssl' -> 'secure';		start.! !!TeapotSslTest methodsFor: 'running'!tearDown	teapot stop.	self pemFile delete.! !!TeapotSslTest methodsFor: 'tests'!testHttpsGet	self skip.	"| result |	result := ZnEasy get: 'https://localhost:1443/ssl'.	self assert: result equals: 'secure'."! !!TeapotSslTest methodsFor: 'private'!writeOutPemTo: aFileReference	aFileReference writeStreamDo: [ :stream | stream nextPutAll: self pemContent ]! !!TeapotStaticFilesTest methodsFor: 'private'!createTempHtdocs	| tmpHtdocs |	tmpHtdocs := FileLocator temp asFileReference / 'test_htdocs'.	tmpHtdocs createDirectory.	tmpHtdocs / 'index.html' writeStreamDo: [ :stream | stream nextPutAll: 'static index' ].	tmpHtdocs / 'a.txt' writeStreamDo: [ :stream | stream nextPutAll: 'a' ].	tmpHtdocs / 'b.txt' writeStreamDo: [ :stream | stream nextPutAll: 'static' ].	^ tmpHtdocs! !!TeapotStaticFilesTest methodsFor: 'running'!setUp	htdocs := self createTempHtdocs.	server := Teapot on		GET: 'here/are/statics/b.txt' -> 'dynamic';		serveStatic: 'here/are/statics' from: htdocs;		start! !!TeapotStaticFilesTest methodsFor: 'running'!tearDown	htdocs deleteAll.	server stop.! !!TeapotStaticFilesTest methodsFor: 'tests'!testDynamicContentServedBeforeStatic	self assert: (TeaTestClient httpGetString: '/here/are/statics/b.txt') equals: 'dynamic'.	! !!TeapotStaticFilesTest methodsFor: 'tests'!testStaticFile	self assert: (TeaTestClient httpGetString: '/here/are/statics/a.txt') equals: 'a'.	! !!TeapotStaticFilesTest methodsFor: 'tests'!testStaticIndexHtml	self assert: (TeaTestClient httpGetString: '/here/are/statics') equals: 'static index'.	! !!TeapotStaticFilesTest methodsFor: 'tests'!testStaticNotFound	self assert: (TeaTestClient httpGet: '/here/are/statics/notfound.txt') code equals: 404.	! !!TeapotStreamingTest methodsFor: 'private'!content	^ (ByteArray new: 4096 withAll: 65) asString! !!TeapotStreamingTest methodsFor: 'private'!createDownloadableFile	| file |	file := FileLocator temp asFileReference / 'download.file'.	file writeStreamDo: [ :stream | stream nextPutAll: self content ].	^ file! !!TeapotStreamingTest methodsFor: 'private'!deleteDownloadableFile	downloadFile delete! !!TeapotStreamingTest methodsFor: 'running'!setUp	downloadFile := self createDownloadableFile.	server := Teapot on		GET: '/stream' -> downloadFile readStream;		output: #stream;		start! !!TeapotStreamingTest methodsFor: 'running'!tearDown	self deleteDownloadableFile.	server stop.! !!TeapotStreamingTest methodsFor: 'tests'!testStreamingContent	self 		assert: (TeaTestClient httpGet: '/stream') contents asString 		equals: self content	! !!TeapotTeaResponseTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/ok' -> (TeaResponse ok body: 'tested ok');		GET: '/badrequest' -> [:req | TeaResponse badRequest body: 'Bad Request'];		GET: '/created' -> [:req | TeaResponse created body: 'Created'; location: req url];		GET: '/notallowed' -> [:req | TeaResponse methodNotAllowed ];		GET: '/notfound' -> [:req | TeaResponse notFound ];		GET: '/notmodified' -> [:req | TeaResponse notModified ];		GET: '/redirect' -> (TeaResponse redirect location: '/target');		GET: '/servererror' -> (TeaResponse serverError body: 'tested server error');		GET: '/unauthorized' -> (TeaResponse unauthorized body: 'Unauthorized'; headerName: 'WWW-Authenticate' value: 'tested unauthorized');		start! !!TeapotTeaResponseTest methodsFor: 'running'!tearDown	server stop.! !!TeapotTeaResponseTest methodsFor: 'tests'!testBadRequest	| response |	response := TeaTestClient httpGet: '/badrequest'.	self assert: response code equals: 400.	self assert: response entity string equals: 'Bad Request'! !!TeapotTeaResponseTest methodsFor: 'tests'!testCreated	| response |	response := TeaTestClient httpGet: '/created'.	self assert: response code equals: 201.	self assert: response entity string equals: 'Created'.	self assert: (response headers at: 'Location') equals: '/created'.! !!TeapotTeaResponseTest methodsFor: 'tests'!testMethodNotAllowed	| response |	response := TeaTestClient httpGet: '/notallowed'.	self assert: response code equals: 405.! !!TeapotTeaResponseTest methodsFor: 'tests'!testNotFound	| response |	response := TeaTestClient httpGet: '/notfound'.	self assert: response code equals: 404.! !!TeapotTeaResponseTest methodsFor: 'tests'!testNotModified	| response |	response := TeaTestClient httpGet: '/notmodified'.	self assert: response code equals: 304.! !!TeapotTeaResponseTest methodsFor: 'tests'!testOk	| response |	response := TeaTestClient httpGet: '/ok'.	self assert: response code equals: 200.	self assert: response entity string equals: 'tested ok'.! !!TeapotTeaResponseTest methodsFor: 'tests'!testRedirect	| response |	response := TeaTestClient httpGetNoRedirect: '/redirect'.	self assert: response code equals: 302.	self assert: (response headers at: 'Location') equals: '/target'.! !!TeapotTeaResponseTest methodsFor: 'tests'!testServerError	| response |	response := TeaTestClient httpGet: '/servererror'.	self assert: response code equals: 500.	self assert: response entity string equals: 'tested server error'! !!TeapotTeaResponseTest methodsFor: 'tests'!testUnauthorized	| response |	response := TeaTestClient httpGet: '/unauthorized'.	self assert: response code equals: 401.	self assert: response entity string equals: 'Unauthorized'.	self assert: (response headers at: 'WWW-Authenticate') equals: 'tested unauthorized'.! !!TeapotWhenClauseTest methodsFor: 'running'!setUp	server := Teapot on		any: '/when' -> 'get'; when: [:req | req method = 'GET'];		any: '/when' -> 'post'; when: [:req | req method = 'POST'];		any: '/when/<p>' -> 'param-dispatch'; when: [:req | (req at: #p) = 'pval'];		any: '/when' -> 'unfiltered';		any: '/never' -> 'never match'; when: [ false ];		before: '/*' -> [:req | 			req abort: (TeaResponse ok body: 'before') ]; 			when: [:req | req relativeUrl path = 'beforeurl' ];		after: '/*' -> [:req :resp | 			resp statusLine: ZnStatusLine ok. 			resp entity: (ZnStringEntity text: 'after') ]; 			when: [:req | req relativeUrl path = 'afterurl' ];		start! !!TeapotWhenClauseTest methodsFor: 'running'!tearDown	server stop! !!TeapotWhenClauseTest methodsFor: 'tests'!testDispatchesOnMethodInWhenFilter	self 		assert: (TeaTestClient httpGetString: '/when') 		equals: 'get'.		self 		assert: (TeaTestClient httpPutString: '/when/pval') 		equals: 'param-dispatch'.	self 		assert: (TeaTestClient httpPostString: '/when') 		equals: 'post'.	self 		assert: (TeaTestClient httpDeleteString: '/when') 		equals: 'unfiltered'.			self assert: (TeaTestClient httpGet: '/never') isNotFound.! !!TeapotWhenClauseTest methodsFor: 'tests'!testWhenClauseWithBeforeAfterFilter	self 		assert: (TeaTestClient httpGetString: '/beforeurl') 		equals: 'before'.	self 		assert: (TeaTestClient httpGetString: '/afterurl') 		equals: 'after'.! !!TeapotWithTypeConstraintTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/u/<identifier:IsUUID>/more' -> [ :req | (req at: #identifier) asString ];		GET: '/u' -> 'no uuid';		GET: '/u/<identifier:IsUUID>' -> [ :req | (req at: #identifier) asString36  ];				start! !!TeapotWithTypeConstraintTest methodsFor: 'running'!tearDown	server stop! !!TeapotWithTypeConstraintTest methodsFor: 'tests'!testNoParams	self 		assert: (TeaTestClient httpGetString: '/u') 		equals: 'no uuid'.	! !!TeapotWithTypeConstraintTest methodsFor: 'tests'!testParseTypeConstraint	self 		assert: (TeaTestClient httpGetString: '/u/964d5d07-1834-0d00-a106-47ae08909eb2') 		equals: (UUID fromString: '964d5d07-1834-0d00-a106-47ae08909eb2') asString36.	! !!TeapotWithTypeConstraintTest methodsFor: 'tests'!testParseTypeConstraint2	self 		assert: (TeaTestClient httpGetString: '/u/964d5d07-1834-0d00-a106-47ae08909eb2/more') 		equals: '964d5d07-1834-0d00-a106-47ae08909eb2'.	! !!TeaTestClient class methodsFor: 'private'!httpDelete: aString	^ ZnEasy delete: 'http://localhost:1701', aString	! !!TeaTestClient class methodsFor: 'private'!httpDeleteString: aString	^ ZnClient new		url: 'http://localhost:1701', aString;		delete	! !!TeaTestClient class methodsFor: 'private'!httpGet: aString	^ ZnEasy get: 'http://localhost:1701', aString	! !!TeaTestClient class methodsFor: 'private'!httpGetNoRedirect: aString	^ ZnClient new		followRedirects: false;		get: 'http://localhost:1701', aString;				response	! !!TeaTestClient class methodsFor: 'private'!httpGetString: aString	^ (self httpGet: aString) entity string	! !!TeaTestClient class methodsFor: 'private'!httpPost: aString	^ ZnEasy post: 'http://localhost:1701', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private'!httpPostString: aString	^ (self httpPost: aString) entity string	! !!TeaTestClient class methodsFor: 'private'!httpPut: aString	^ ZnEasy put: 'http://localhost:1701', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private'!httpPutString: aString	^ (self httpPut: aString) entity string	! !"Teapot-Tests"!!TeaFormTab commentStamp: '' prior: 0!I'm built up from a dynamically extensible key value pair list (TeaKeyValueInput). I can represent POST parameters or HTTP headers for example.!!TeaKeyValueInput commentStamp: '' prior: 0!Two inputs and a remove button.!!TeaRequestBodyTabs commentStamp: '' prior: 0!I graphically represent a request body that can be viewed in multiple ways.!!Teaspoon commentStamp: '' prior: 0!I provide a graphical interface for quickly testing and excesising routes. Right click on a route in the inspector to open me.!!TeaKeyValueList commentStamp: '' prior: 0!I'm built up from a dynamically extensible list of other components.!!Cupboard commentStamp: '' prior: 0!A cupboad for teapots!!TeaIconProvider commentStamp: '' prior: 0!An icon provider for tools icons with an icon cache!!TeaRoute methodsFor: '*Teapot-Tools'!gtInspectorRouteIn: composite	<gtInspectorPresentationOrder: 80>	| presentation |	presentation := composite morph.	presentation		title: 'Teaspoon';		display: 			[ | teaspoon |				teaspoon := Teaspoon new 					method: requestMatcher methodMatcher asString					url: requestMatcher urlPattern asTeaspoonPath					port: port.				teaspoon onHttpResultDo: [ :result | presentation selection: result ].				teaspoon buildWithSpec ]! !!TeaRxUrlPattern methodsFor: '*Teapot-Tools'!asTeaspoonPath	^ '/'! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools'!asRequestBuilderPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools'!asTeaspoonPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!Teapot methodsFor: '*Teapot-Tools'!browse	WebBrowser openOn: 'http://localhost:', self server port asString! !!Teapot methodsFor: '*Teapot-Tools'!gtInspectorAfterFilterIn: composite	<gtInspectorPresentationOrder: 2>  		^(composite table)		title: ['After Filter' translated];		 		display: [ compositeRouter afterFilters ]; 		column: 'Request matcher' evaluated: [:filter| filter requestMatcher ];		column: 'Action' evaluated: [:filter| filter action ];		selectionAct: [:p | p entity removeAfterFilter: p selection. 			p pane browser update ] entitled: 'Remove filter' translated;		selectionAct: [:p | p entity removeAllAfterFilters. 			p pane browser update ] entitled: 'Remove all' translated! !!Teapot methodsFor: '*Teapot-Tools'!gtInspectorBeforeFilterIn: composite	<gtInspectorPresentationOrder: 1>  		^(composite table)		title: ['Before Filter' translated];		 		display: [ compositeRouter beforeFilters ];		column: 'Request matcher' evaluated: [:filter| filter requestMatcher ];		column: 'Action' evaluated: [:filter| filter action ];		selectionAct: [:p | p entity removeBeforeFilter: p selection. 			p pane browser update ] entitled: 'Remove filter' translated;		selectionAct: [:p | p entity removeAllBeforeFilters. 			p pane browser update ] entitled: 'Remove all' translated! !!Teapot methodsFor: '*Teapot-Tools'!gtInspectorDynamicRoutesIn: composite	<gtInspectorPresentationOrder: 0>  		^(composite list)		title: ['Dynamic routes' translated];		 		display: [ dynamicRouter routes ]; 		format: [:each | each printString ];		selectionAct: [:p | p entity removeDynamicRoute: p selection. 			p pane browser update ] entitled: 'Remove route' translated;		selectionAct: [:p | p entity removeAllDynamicRoutes. 			p pane browser update ] entitled: 'Remove all' translated! !!Teapot methodsFor: '*Teapot-Tools'!removeAfterFilter: aFilter	compositeRouter afterFilters remove: aFilter! !!Teapot methodsFor: '*Teapot-Tools'!removeAllAfterFilters 	compositeRouter afterFilters removeAll! !!Teapot methodsFor: '*Teapot-Tools'!removeAllBeforeFilters 	compositeRouter beforeFilters removeAll! !!Teapot methodsFor: '*Teapot-Tools'!removeAllDynamicRoutes 	dynamicRouter routes removeAll! !!Teapot methodsFor: '*Teapot-Tools'!removeBeforeFilter: aFilter	compositeRouter beforeFilters remove: aFilter! !!Teapot methodsFor: '*Teapot-Tools'!removeDynamicRoute: aRoute	dynamicRouter routes remove: aRoute! !!TeaFormTab class methodsFor: 'specs'!defaultSpec	^ SpecLayout composed		newColumn: [ :col |			col 				add: #form;				add: #addButton height: self buttonHeight ]! !!TeaFormTab methodsFor: 'accessing'!addButton	^ addButton ! !!TeaFormTab methodsFor: 'accessing'!form	^ form! !!TeaFormTab methodsFor: 'initialization'!initializePresenter	addButton whenActionPerformedDo: [ form addKey: '' value: '' ]! !!TeaFormTab methodsFor: 'initialization'!initializeWidgets	addButton := self newButton label: 'Add parameter'; yourself.	form := self instantiate: TeaKeyValueList.	self focusOrder 		add: form;		add: addButton.! !!TeaFormTab methodsFor: 'protocol'!updateKeyValus: keyValueCollection	form items: keyValueCollection! !!TeaFormTab methodsFor: 'private'!urlEncoded	| url formParams |	url := '/' asZnUrl.	formParams := form items.	formParams ifEmpty: [ ^ '' ].	formParams do: [ :association | url := url withQuery: association ].	^ url asString allButFirst: 2	! !!TeaFormTab methodsFor: 'protocol'!writeUrlEncodedTo: aTextModel	self urlEncoded 		ifNotEmpty: [ aTextModel text: self urlEncoded ]! !!TeaKeyValueInput class methodsFor: 'specs'!defaultSpec	^ SpecLayout composed		newRow: [ :row |			row				add: #keyInput;				add: #valueInput;				add: #removeButton ]		 height: self height! !!TeaKeyValueInput class methodsFor: 'accessing'!height	^ self inputTextHeight max: self buttonHeight! !!TeaKeyValueInput class methodsFor: 'instance creation'!key: keyString value: valueString removeAction: aBlock	^ self new		setKey: keyString 		value: valueString		removeAction: aBlock! !!TeaKeyValueInput methodsFor: 'converting'!asAssociation	^ keyInput text -> valueInput text! !!TeaKeyValueInput methodsFor: 'initialization'!initializeWidgets		keyInput := self newTextInput autoAccept: true; ghostText: 'key'; yourself.	valueInput := self newTextInput autoAccept: true; ghostText: 'value'; yourself.	removeButton := self newButton label: 'Remove'; yourself.	self focusOrder		add: keyInput;		add: valueInput;		add: removeButton.		! !!TeaKeyValueInput methodsFor: 'accessing'!keyInput	^ keyInput! !!TeaKeyValueInput methodsFor: 'accessing'!removeButton	^ removeButton! !!TeaKeyValueInput methodsFor: 'initialization'!setKey: keyString value: valueString removeAction: aBlock	keyInput text: keyString.	valueInput text: valueString.	removeButton whenActionPerformedDo: [ aBlock value: self ].	^ self! !!TeaKeyValueInput methodsFor: 'accessing'!valueInput	^ valueInput! !!TeaRequestBodyTabs class methodsFor: 'specs'!defaultSpec	^ SpecLayout composed		newColumn: [ :col |			col 				add: #label height: self inputTextHeight;				add: #requestBody ]! !!TeaRequestBodyTabs methodsFor: 'private'!formTabTitle	^ 'Form'! !!TeaRequestBodyTabs methodsFor: 'initialization'!initializeWidgets	label := self newLabel label: 'Request body'; yourself.	requestBody := self newRequestBody.! !!TeaRequestBodyTabs methodsFor: 'accessing'!label	^ label! !!TeaRequestBodyTabs methodsFor: 'initialization'!newRequestBody	raw := self newText		autoAccept: true;		yourself.	form := TeaFormTab new.	^ self newTabManager		addTab:			(self newTab				label: self rawTabTitle;				closeable: false;				model: raw);		addTab:			(self newTab				label: self formTabTitle;				closeable: false;				model: form);		whenTabSelected: [ :selected | 			selected label = self formTabTitle				ifTrue: [ form updateKeyValus: ('?' , raw text) asUrl query ]				ifFalse: [ form writeUrlEncodedTo: raw ] ]! !!TeaRequestBodyTabs methodsFor: 'private'!rawTabTitle	^ 'Raw'! !!TeaRequestBodyTabs methodsFor: 'accessing'!requestBody	^ requestBody! !!TeaRequestBodyTabs methodsFor: 'protocol'!urlEncoded	requestBody selectedTab label = self formTabTitle		ifTrue: [ raw text: form urlEncoded ].	^ raw text! !!Teaspoon class methodsFor: 'specs'!defaultSpec	^ SpecLayout composed		newColumn: [ :col | 												col 				newRow: [ :row | 					row 						add: #methodDropList width: 90;						add: #urlInput ]				height: self inputTextHeight.			col				add: #requestBody;				add: #contentTypeLabel height: self inputTextHeight;				add: #contentTypeDropList height: self inputTextHeight.			col 				newRow: 					[ :row | row add: #execButton ] 				height: self buttonHeight						]! !!Teaspoon class methodsFor: 'private - accessing'!iconProvider	^TeaIconProvider ! !!Teaspoon class methodsFor: 'world menu'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teaspoon')	 		help: 'Teaspoon'; 		parent: #'Tools' translated;		icon: self iconProvider teaspoonIcon;		action: [ self open ].! !!Teaspoon class methodsFor: 'interface'!open	<script>		(self new)		openWithSpec;		yourself! !!Teaspoon class methodsFor: 'specs'!title	^ 'Teaspoon client'! !!Teaspoon methodsFor: 'private'!client	^ ZnClient new		url: self urlInput text;		method: self methodDropList selectedItem;		entity: (ZnStreamingEntity 			readFrom: (ReadStream on: requestBody urlEncoded)			usingType: self contentTypeDropList selectedItem			andLength: requestBody urlEncoded size)		yourself! !!Teaspoon methodsFor: 'private'!consumer	^ consumer ifNil: [ consumer := [ :any | any inspect ] ]! !!Teaspoon methodsFor: 'accessing'!contentTypeDropList	^ contentTypeDropList! !!Teaspoon methodsFor: 'accessing'!contentTypeLabel	^ contentTypeLabel! !!Teaspoon methodsFor: 'accessing'!execButton	^ execButton! !!Teaspoon methodsFor: 'api'!initialExtent	^  580@420! !!Teaspoon methodsFor: 'initialization'!initializePresenter	execButton		whenActionPerformedDo: [ 			self urlInput text notEmpty				ifTrue: [ self consumer value: self client execute ]]! !!Teaspoon methodsFor: 'initialization'!initializeWidgets	methodDropList := self newMethodDropList.	urlInput := self newTextInput autoAccept: true; yourself.	requestBody := TeaRequestBodyTabs new.	contentTypeLabel := self newLabel label: 'Content Type'; yourself.	contentTypeDropList := self newContentTypeDropList.	execButton := self newButton label: 'Execute request'; yourself.! !!Teaspoon methodsFor: 'tea spoon'!method: methodString url: urlString port: portNumber	self populateMethod: methodString.	self populateUrl: urlString port: portNumber.! !!Teaspoon methodsFor: 'accessing'!methodDropList	^ methodDropList! !!Teaspoon methodsFor: 'initialization'!newContentTypeDropList	| dropList |	dropList := self newDropList.	#(		applicationFormUrlEncoded 		applicationJson 		applicationXml 		applicationSton 		applicationOctetStream 		text 		textHtml 		textPlain	) do: [ :each | dropList addItemLabeled: (each value: ZnMimeType) do: [] ].		^ dropList! !!Teaspoon methodsFor: 'initialization'!newMethodDropList	| dropList |	dropList := self newDropList.	ZnConstants knownHTTPMethods do: [ :each | 		dropList addItemLabeled: each do: [] ].	^ dropList! !!Teaspoon methodsFor: 'tea spoon'!onHttpResultDo: aBlock	consumer := aBlock! !!Teaspoon methodsFor: 'private'!populateMethod: methodString	| selected |	selected := methodDropList listItems		detect: [ :each | each = methodString ]		ifNone: [ methodDropList listItems first ].	methodDropList setSelectedItem: selected! !!Teaspoon methodsFor: 'private'!populateUrl: urlString port: portNumber	| pathSegment |	pathSegment := urlString.	(pathSegment beginsWith: '/') 		ifFalse: [ pathSegment := '/', pathSegment ].		urlInput text: ('http://localhost:', portNumber asString, pathSegment)! !!Teaspoon methodsFor: 'accessing'!requestBody	^ requestBody! !!Teaspoon methodsFor: 'accessing'!urlInput	^ urlInput! !!TeaGlobUrlPattern methodsFor: '*Teapot-Tools'!asTeaspoonPath	^ String streamContents: [ :aStream |			segments 				do: [ :each | each printOn: aStream ]				separatedBy: [ aStream nextPut: $/ ] ]! !!TeaKeyValueList class methodsFor: 'specs'!defaultSpec	^ SpecLayout composed! !!TeaKeyValueList methodsFor: 'protocol'!addKey: keyString value: valueString	self needFullRebuild: false.		self buildWithSpecLayout: 		(self dynamicLayout: 			(self asAssociations copyWith: keyString -> valueString))! !!TeaKeyValueList methodsFor: 'private'!asAssociations	^ models collect: #asAssociation! !!TeaKeyValueList methodsFor: 'private'!dynamicLayout: associations	self focusOrder removeAll.	models removeAll.	self widgets removeAll.	^ SpecLayout composed newColumn: [ :col |			associations doWithIndex: [:assoc :i | 				| inputName widget |				inputName := ('input', i asString) asSymbol.				self instantiateModels: {inputName.  #TeaKeyValueInput}.				widget := self perform: inputName.				widget					setKey: assoc key					value: assoc value					removeAction: [ :me | self remove: me ].				models add: widget.				self focusOrder add: widget.				col 					newRow: [ :row | row add: inputName ] ] ].		! !!TeaKeyValueList methodsFor: 'initialization'!initialize	super initialize.	models := OrderedCollection new.! !!TeaKeyValueList methodsFor: 'protocol'!items	^ self withoutDuplicatesAndBlanks: (self asAssociations asOrderedDictionary)! !!TeaKeyValueList methodsFor: 'protocol'!items: keyedCollection	self needFullRebuild: false.	self buildWithSpecLayout: 		(self dynamicLayout: 			(self withoutDuplicatesAndBlanks: keyedCollection))! !!TeaKeyValueList methodsFor: 'private'!remove: model	self needFullRebuild: false.	models remove: model.	self buildWithSpecLayout: (self dynamicLayout: self asAssociations)! !!TeaKeyValueList methodsFor: 'private'!withoutDuplicatesAndBlanks: keyedCollection	| keyset |	keyset := PluggableSet new		equalBlock: [ :a :b | a key = b key ];		hashBlock: [ :x | x key hash ];		yourself.					keyedCollection keysAndValuesDo: [ :key :value | 		keyset add: (key -> value) ].	^ keyset reject: [ :each | 		each key isEmptyOrNil or: [ each value isEmptyOrNil ] ]! !!Cupboard class methodsFor: 'accessing'!iconProvider	^TeaIconProvider! !!Cupboard class methodsFor: 'world menu'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teapot')	 		help: 'Teatime'; 		parent: #'Tools' translated;		icon: self iconProvider teapotIcon;		action: [ self soleInstance inspect ].	 aBuilder withSeparatorAfter ! !!Cupboard class methodsFor: 'instance creation'!new	self error: 'Do not create new instances - access using #soleInstance'! !!Cupboard class methodsFor: 'private'!reset	<script>		soleInstance := nil.	 ! !!Cupboard class methodsFor: 'accessing'!soleInstance	<script: 'self soleInstance inspect'>		^ soleInstance ifNil: [ soleInstance := self basicNew initialize ]! !!Cupboard methodsFor: 'inspecting'!gtInspectorTeapotsIn: composite	<gtInspectorPresentationOrder: 0>  		^(composite list)		title: 'Teapots';		icon: [:each | self iconForTeapot: each ];		display: [ self teapots ]; 		format: [:each | self nameForTeapot: each ];		selectionAct:  [:each | each selection ifNotNil: [ each selection start ]. each update ] icon: self iconProvider teapotServerStartIcon entitled: 'Start';		selectionAct: [:each | each selection ifNotNil: [ each selection stop ]. each update ] icon: self iconProvider teapotServerStopIcon entitled: 'Stop';		selectionAct: [:each | each selection ifNotNil: [ each selection browse ]. each update ] icon: self iconProvider teapotServerIcon entitled: 'Browse';		act: [:each | self onNewServer. each update ] icon: self iconProvider teapotServerIcon entitled: 'New Teapot';		act: [:each | self onNewStaticServer. each update ] icon: self iconProvider teapotServerStaticIcon entitled: 'New Teapot (serving static)'		! !!Cupboard methodsFor: 'private'!iconForTeapot: aTeapot	^aTeapot server isRunning 			ifTrue: [ self iconProvider teapotServerStartIcon ] 			ifFalse: [ self iconProvider teapotServerStopIcon ]! !!Cupboard methodsFor: 'accessing'!iconProvider	^self class iconProvider! !!Cupboard methodsFor: 'private'!nameForTeapot: aTeapot	^String streamContents: [:stream |		stream nextPutAll: aTeapot server port asString.		stream nextPutAll: ' - '.		stream nextPutAll: (aTeapot server isRunning ifTrue: [ 'running' ] ifFalse: [ 'stopped' ]) ].! !!Cupboard methodsFor: 'actions'!onNewServer	|port pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot start			! !!Cupboard methodsFor: 'actions'!onNewStaticServer	|port directory pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^self ].	directory := UIManager default chooseDirectory: 'Serve directory'.	directory ifNil: [ ^self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot serveStatic: '/' from: directory.	pot start			! !!Cupboard methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'Cupboard'! !!Cupboard methodsFor: 'accessing'!teapots	^Teapot allInstances! !!TeaIconProvider class methodsFor: 'private - icons'!form: base64String	^ Form fromBinaryStream: (base64String base64Decoded asByteArray readStream)! !!TeaIconProvider class methodsFor: 'accessing'!icons	IconCache ifNil: [ IconCache := Dictionary new ].	^IconCache! !!TeaIconProvider class methodsFor: 'icons'!teapotIcon	^ self icons			at: #'teapotIcon'			ifAbsentPut: [ self form: self teapotIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhklEQVR42rWSPSxDURTHzzmvr8TyRBP00Y1BQiwiRD+YkKiPyWqTSDAZjUaj2SyS0lbEpNWPRCTEYBeNKrv4qN57nFYiPoqXNM7Nzcs799zf/Z//vQg1Bv4rIO4LdDCgF5FPwrn0s2PAdmsf1RkNvbK6KbMLGGaR4SCcTz19A0S8A3NkGo/TuexWORG1A/2MvE9EHuQ3PsuQeFFcWjXQtaEVjpHBzZLexj07cK4Je1jTKBn6khmzCNzyJo7h41dAD8z6FJEs+TuT1hijdnAICdJS8ShFRSlv/Ms4Zp6ZzKd2Y75gBqM+v9DoChgt587zsrtObRSLdFFpMm4Hk0AQcgpw89N6CdyHCnGtAthp93e6gI6l0yZ08DTEi1NibSmCpffqeFvILF+C3MD47/LFK8Y9MNRiOJe5+3RczDviYXpJisvdP+wXo2FCVCbC10dc9SHF7eF6QD2vUC8Qkkf0uiT9wFon5OSVqUL65oui6hGxBy3TMMsAU+Y9Ki5M3KZ1lZZqi5oBr2z5j75RN5raAAAAAElFTkSuQmCC'! !!TeaIconProvider class methodsFor: 'icons'!teapotServerIcon	^ self icons			at: #'teapotServerIcon'			ifAbsentPut: [ self form: self teapotServerIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotServerIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR4Xo2SbU+SURzG+RS2hDdufQBtM0e58GHa8o2W3mbWkjbLhzURTTNEHnwowNKG2oM6JUWF2+fHTJ2aJaFCPlAzJygGOMPM8qF8wqtbXli2rK7t2v7n7Fy/c8520fbk4nKEkZkpIUViKckXSEj9qBEjehNG3kxDILxLenoyCVdXVwbtMHl7s4hJ4ypsi1uUHbDad2Fz2kGtd2G2bWBIZ0Jz6wvLHtDL69RBIIvlS2hGFqEbW4FhcgWmuU0YzduYNu9QswOmDw7MWhwUaAe2Tw7M29dxIyGV3Af4+voR3X1mDAwuoLd/Hl09c9Q8D/34MgVcxYz1O+yft2Ff3sTYWxvKK/oRxU44CGhpe4/Orlm0tk+joWkS6toJ1KhHoax5jdLyPsgLn0GUrUZMnBTnw64jPj7lIEBNjqK+8R1U5DiU1XqUP9WitGwQfEEJMgRS5D8ohrJKjampKQhF9+HjG8j9BeBPlCk0qFDqUKbQ4knJSzwsom6Vd1N/lcJgMGBraxvf1jfw5es64mJvwfMEk9gHBAaeIeQFXXhcPIDCwl7k5z9HrqwDUkkL2Ox0aLXDWFvbwsLCMmZm7QgJYeNsUNBPgLu7B1MirUdeXidk0nbkZDdBLKqjXIuIiBS0tXXBal2C0bSEVxoTgoOjQGfQD/YiLU1MioQqZ1AoUEOQoYZISCI8PBnVNc2YMFiocpnR1jEM9lUO/lioa9FJZDqvygnYsxNwIQmKikYqbMGAZgbquh4kcsU4tJUyWYklg6/aBxDhXBQ9UkE3/hGDQzNIThUg5BxbcyjgKFVRHk9uEWSonIAwgoukm3eo0CW4uR1DQEAktRdN0v4md4/jTA4n17L3ipjYe2D5ROK0z0VcTuSBL6zElajYPNq/5OcfQGRlKZHAKaLal4/bPAXkBa3IypZr6HQ6g/Y/8vI6SVRW9qChUYPsnCJNaGgE9/czPwCyhvLlWzqQAwAAAABJRU5ErkJggg=='! !!TeaIconProvider class methodsFor: 'icons'!teapotServerStartIcon	^ self icons			at: #'teapotServerStartIcon'			ifAbsentPut: [ self form: self teapotServerStartIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotServerStartIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADR0lEQVR4Xn2T71fTZRyG+S804RV56k3Hc6jciTpHICnNOnVYfCWhCZiiCAxGlEbbhCg2TjQdIYlCwWIIU0crDhAiiOA8xL6B4kFqG7+22QYRHCL5Nbia7ByOnNPpc859zvPmup7nOef+hDw5JzOydQWfaU0qtdYkDjro/9VJv2in8lKdVaMtNUkkksiQ/xtr3ygu3yqe6TU8U4+zHjgHM/FwmT5xFMtP3S71GY1JocjT7dgRGrZF0NH1O+LdBe7en8c+tohzfBXHmB/HhB/n5BpjrkA8fh4GLnB7/0aRm2/aImhpG6LH6qOz20N7xwQ3ezzYBv/i3vBCAF7CN7PK1NwyA0Muqr69wcmMj7cKmiw22q6P09xip8nyANPVIeobBqhv/IXq7zopK2+l4PNG0k5oiBfSSUxM1W0RNDRaMf8wTOOVe9TVi9QY+rhY1UthkQGlUsPZc5UYjSbsdgenPikmIkIibMK7JS9G5p0vIfF8Dqll+ZRUmKmouIlef52c3HOINhsrKys8+meZ2dkFUlKziY19LSiQ7JUIh5vep2SgmNbJFgy/1XC09SgHNXI0xRbSjmvo6uxiIQB7vbPYHX8glaYSFxcnhGx7altYglmgxl5Ns+tHFlcfMTI3TJ2zluzeLA4pPyLlSCENDddwu2dwOP+kq/tB4P/pbNwe/UGU7thtGbXOSuaX51hfX9+IdfoW+pESdpdHkpx6hksXjQzdn6TfNo7Z0kumXBUUPK/YZZKLR5ha9G7Cj+Nf82NxX+E5YziyFCXlFbXYRDc9t0epu9yCUlUaFLycJzEliq9TMfkF7TPmALyGb9nDhUkN6hE5uy4/TVLyp3xZWoU46KM30FZ5zile3SsNdkCaJdW9eecF0u1vUT+t3xC4lhx86BQ4OPgKMd/EIktWkZmlJu5dGeHhO9m3T4bscEZQEBoWGpbbeZwi1zF+nq8LvmBlgq+8uSTciiFNpSUzs4zomCT2RL9HUk4+6oLv2f/GO4rNDhx4+4CQcTXFVTRygralKmqnNMithyisLrBqtUYUiguB9p3ldH4N+q+bAxU+bfrPbYzaHyVsj9guPBv5jCB5Kbi6UXtiBIOhnWvmO3TcsBEfn6B4kvkXxV9YN+ClYBQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons'!teapotServerStaticIcon	^ self icons			at: #'teapotServerStaticIcon'			ifAbsentPut: [ self form: self teapotServerStaticIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotServerStaticIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADIElEQVR42l2Ta0gUURTH/1fHWVNz2dLNIinQ0shAKCsSixIp7EMQ7VKbH8SICopo6UFaiBqZBm5R1Bc1i7ZwJw1DlzbQfKTr9rA+aGX2MFbbNsu21Np259Gdcczwwsw5c+85vzn/e+8hoCM0NHThjh07KySJQBAl5BcUGUSRAEREWWkh19Ls4H788DkFQRjCjEHkV0xMrKGj+70tWquRcZBBygIkGkEQDATg9Qyjr/f5kL2p3vmw5QHn831XgEpcbKze0GDvs7FhGmgoIyJCQyEhNJ0ghBDlNyGyCZEQpqFw0Y+8XBN3395gVAB6vd5grX1s07Dh4IMieD6I8FlhiIyaBZZlEDmbQVQEo0j6NPwVz3sGcL26nGtttU8DKqvbbSyrQTDIq08QoijQPfHD7/fj14Qfo76f8AwPYmTkHSbGPnMOx71pwKXLDhsTxirJPD8JoBoxOPiSKhjFnDk6KlWLtFWpuHW7EdVVl8xu96BFBcwznCu/a2MYdjo5QEECjzdve7BvbzaSkpKpPAEBXsDJE8WotVUaR0e/cQogLi7OkF9ww8Zq6B4EJgFysCjyePXahf37tyElJRXj4xP49TsI85HjcLkcRo/Hw5HVaQlRSUv0pdu3rj/IIAj30E/09Osxf8EKMAxDAY+Rk5OF1NSV8P8BPnt9OF9WjMamm/ECT48xL3fzoePmLSW6CEYLegISL6HD9RFdL3jodDqMfHEjOTke0XOTkLw8HV7vF9zhrKi5dlGpnpwpybHmH0s3EZ5+C/Tq8HRSkFQ7OQfqV9S+QtrGw/B8eg9nZycuWApVQNFua8HRDJMcJKnBRJj0CfX/Abh+rM06hPq6Gjx1PXO2tTWtUwAlhbsoYINJDpbUBKLCiJoszx04WwfHow9ITFyNsXEv1+1sNiqA4tNG6ynzRhNouUSYgkhqJdMS9pzhEIhbg8XaZXDYr1qePOkyK4CiUwbr6SOZJjJTgmqnAEevtGJRym709j50VlVeNE51Jtm0IcWcmbE0WxLpCdBWlgQRoFdY9sfG/PqYeQkr5IZqfzrg7n/nsQwM9Fv+b+e/lwaeIIipiHQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons'!teapotServerStopIcon	^ self icons			at: #'teapotServerStopIcon'			ifAbsentPut: [ self form: self teapotServerStopIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotServerStopIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADO0lEQVR4Xn2T7U+TVxiH+xdsGfso0Q+Gbh+UBYFEsjeSzS6yKWDWdKyMurEXytDyVsfcKHRtFKdWRFyljxoiVbEoq3vxPVM2qKwd5XXZYK30BYotuEXWQaSUa8/GdDZLdidX7i/nvk7OOb8jebhK399uqtfvsdXqGmx9A15cbi9Ot4cWi9VRUrLNtGnTZrnk/6q710swHCM0vchkeInJyH3iTIQX+WHAj6vPw8e1u2ylpRrTunXpWQmCq9+M4h6KMjByl7HxOby+RTzjcbx+kcAStwJxxicWRVmc8K/3uHSlhwTB1xeH+c4R4XpXiCvXAlz/Nige4w6DI7/j8c8zNR1j5m6MUe805+xOzC32REGn3cXlq36+uuDh8/M/Yzs7zKn2fto7XAitN2g+chljQwea8kMoCspQKsscCYJT7T102n/iTMcQJ0+7aT3hRDjWw8HmC2zbvpP9piMcP96G0+nCaj1NXv5W24PhZLGExjO06Fux7LdjOdrNZ+YbHGy6hmFXO21tVhYWYszP32N2do69ew/xVrFmWaDKzatoK1IFbxoM/GhpoddoxKpS0/CBwO7dX1Dz4TGaD5uZm1sgEpklEJihvEJHdfVHNsnG7Gz5RaUSryA84NY/vXOLAl25mR07BOrqDExMzuAL/IZ78DbKwjLS0jLlEqtCERyqqmasvp5fHmJUZKSmhk8zXxJ3sqDV1jI8EqSv3ye+zCQvv1LIixtkcok9dS1Rv49YNCryR0JfiM5yMvNpqkSBpnwn/YMhurq99Nz0kpPzOiuSVyRLvpRKmQuFiC/F/0s8ztn09VRWmSlRa+l1BcWQ3WHPvhaKVGXLGegqKGAsO5tg7mZuFxYSURUxVfgGvtw8RmUyhLTnqKg0o3jtXd4s1iBNeZL1WTL0emFZ8Iw0Rf79Y0kEVq4kLBJZtYopsY+LOB55FJ2qXrwDgRc2bOXZ5xW8qq5AU3kYXd2Bf0O0JUVaMZiRQTQ3l/miImbz8xlIz0AoUTuamjqo1gq8856JKu1R9h04T2OjNZia+lTiR0p9Qppl3JhjM65ZYzPIZLa1q1f/vSAp6fHkE9ZLdJzrRv9Jk6P4bbXpr9Ddn/sTU0VgFvyaFxkAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons'!teaspoonIcon	^ self icons			at: #'teaspoonIcon'			ifAbsentPut: [ self form: (self teaspoonIconContents) ]! !!TeaIconProvider class methodsFor: 'private - icons'!teaspoonIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABdklEQVR42mNkoBAwgoiJs6fLvHv/oe/d27cM6urqTxQVFfq8HV2fEG1AQ1f7qlevX4XCBDk5OBnExcWLynLy+4kyIK+idNWfv39C0SUNDQz7U6PjiggaMG3+3L4r164UokvycPMwdDU0MxI0YNfhgzK7du96/O37NwwFCfEJYWY6+qvxGgACPdMmF967f68PXYG8nHxYeW4BYQNAYM6yxX23bt0q/PL1C1xMVFRsdWNZZRhRBsDA8YtnQw8ePMTw8+fP0JevXoby8vCu7qxvCiPaAGRQ2dyw6uOnj6FArzzR09Oz9LR3ekKSASDQNWXi4wcPH8hwc3E/YefgsGyprHlCkgGgWNqzd89xYNjIMDMxP2FkZLSc1NH9hGgDQKCuo1Xm/fv3x//++yvDyMD4hIWV1XJiW+cTog0AAWCKlfn79+/x/wz/ZZiZmZ+oKCtbkmQACORXlcv8//fvODDpy0hJSh0n2QAQmDx3lsynT59W/fnz5wkA2dSUkQj2i7UAAAAASUVORK5CYII='! !!TeaRequestMatcher methodsFor: '*Teapot-Tools'!urlPattern	^ urlPattern! !"Teapot-Tools"!!NeoJSONBenchmarkTests commentStamp: '' prior: 0!I am NeoJSONBenchmarkTests.This test is obviously dependent on hardware, but the margin is quite high.!!NeoJSONExamplesTests commentStamp: '' prior: 0!NeoJSONExamplesTests runs a couple of examples as tests!!NeoJSONMappingTests commentStamp: '' prior: 0!I am NeoJSONMappingTests, testing more exotic kinds of mapping constructs.!!NeoJSONObjectTests commentStamp: '' prior: 0!I am NeoJSONObjectTests, I hold unit tests for NeoJSONObject.!!NeoJSONReaderTests commentStamp: '' prior: 0!I am NeoJSONReaderTests, a test suite for NeoJSONReader.!!NeoJSONWriteReadTests commentStamp: '' prior: 0!I am NeoJSONWriteReadTests.!!NeoJSONWriteReadAsciiOnlyTests commentStamp: '' prior: 0!I am NeoJSONWriteReadAsciiOnlyTests.!!NeoJSONWriteReadMockStreamTests commentStamp: '' prior: 0!I am NeoJSONWriteReadMockStreamTests.!!NeoJSONWriteReadPrettyPrintedTests commentStamp: '' prior: 0!I am NeoJSONWriteReadPrettyPrintedTests.!!NeoJSONWriterTests commentStamp: '' prior: 0!I am NeoJSONWriterTests, a test suite for NeoJSONWriter.!!NeoJSONBenchmark commentStamp: '' prior: 0!I am NeoJSONBenchmark.I hold 1000 objects of the form Dictionary('color'->'green' 'enabled'->false 'id'->1 'name'->'Name-1' 'value'->0.002 ) in an Array.I hold the JSON serialization of that as a String of the form '[{"value":0.002,"enabled":false,"name":"Name-1","color":"green","id":1}, ...| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] timeToRun.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] timeToRun.!!NeoJSONMockStream commentStamp: '' prior: 0!I am NeoJSONMockStream.I wrap another stream to validate the limited API used.!!NeoJSONTestObject1 commentStamp: '' prior: 0!I am NeoJSONTestObject1.I repesent a domain model object.I have the following properties:- id <Integer>- name <String>- timestamp <DateAndTime>- points <Array of: Point>- bytes <ByteArray>My JSON representation is like this:- id <Number>- name <String>- created-at <ISO8601 String>- points <Array of: <Map x,y>- bytes <Array of: Number>!!NeoJSONTestObject2 commentStamp: '' prior: 0!I am NeoJSONTestObject2.Instance Variables	data:		<String>	height:		<Integer>	id:			<Integer>	width:		<Integer>Used for benchmarking and other tests.!!NeoJSONTestObject3 commentStamp: '' prior: 0!I am NeoJSONTestObject3, a subclass of NeoJSONTestObject2.Instance Variables	color:			<String>	transparent :	<Boolean>I am used for inheritance testing.!!NeoJSONValidation commentStamp: '' prior: 0!I am NeoJSONValidation, a set of tests to validate NeoJSON against some external rules.Both positive & negative tests are includes.Some of these are implementation choices.http://seriot.ch/parsing_json.phphttps://github.com/nst/JSONTestSuitehttps://github.com/nst/JSONTestSuite.git  test_parsing  test_transformhttps://github.com/miloyip/nativejson-benchmarkhttps://github.com/miloyip/nativejson-benchmark.git  data/jsonchecker  data/roundtripThis can only be run with the correct setup (checkout/config).  NeoJSONValidation new runNativeJsonBenchmarkRoundTrip.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerPasses.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingPasses.  NeoJSONValidation new runJsonTestSuiteTestParsingFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingInfo.Logging goes to a file, neo-json-validation.log!!NeoJSONBenchmarkTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 new.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 new! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testPrettyPrinted	| benchmark |	benchmark := NeoJSONBenchmark new.	self		assert: benchmark writePrettyPrintedRead		equals: benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testRead	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testWrite	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark write! !!NeoJSONExamplesTests methodsFor: 'tests'!testPoints	| points json result |		points := Array with: 1@2 with: 3@4 with: 5@6.		json := String streamContents: [ :out |		(NeoJSONWriter on: out)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: points ].			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #ListOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ListOfPoints.		self assert: result equals: points.				result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		nextListAs: Point.		self assert: result equals: points.			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #OrderedCollectionOfPoints customDo: [ :mapping |			mapping listOfType: OrderedCollection andElementSchema: Point ];		nextAs: #OrderedCollectionOfPoints.		self assert: result equals: points asOrderedCollection.! !!NeoJSONExamplesTests methodsFor: 'tests'!testRectanglePoints	| rectangle rectangleJson result |	rectangle := Rectangle origin: 3 @ 4 extent: 5 @ 6.	rectangleJson := String streamContents: [ :stream | 		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			mapInstVarsFor: Rectangle;			nextPut: rectangle ].	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			(mapping mapInstVar: #origin) valueSchema: Point.			(mapping mapInstVar: #corner) valueSchema: Point ];		nextAs: Rectangle.	self assert: result equals: rectangle.	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			mapping mapInstVars do: [ :each | each valueSchema: Point ] ];		nextAs: Rectangle.			self assert: result equals: rectangle ! !!NeoJSONExamplesTests methodsFor: 'tests'!testRectanglePointsWithNils	self		assert: 			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					nextPut: Rectangle new ])		equals: '{}'.	self		assert:			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle	do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					writeNil: true;					nextPut: Rectangle new ])		equals: '{"origin":null,"corner":null}'.! !!NeoJSONMappingTests methodsFor: 'testing'!testDynamicTyping	| data customMapping json result |	data := Array with: 'foo'->1 with: #('foo' 2).	"The idea is to map a key value combination as either a classic association or a simple pair, 	using key & value properties as well as a type property to distinguish between the two"	customMapping := [ :mapper |		mapper 			for: #AssocOrPair customDo: [ :mapping |				mapping					encoder: [ :x | 						x isArray 							ifTrue: [ Dictionary new at: 'type' put: 'pair'; at: 'key' put: x first; at: 'value' put: x second; yourself ] 							ifFalse: [ Dictionary new at: 'type' put: 'assoc'; at: 'key' put: x key; at: 'value' put: x value; yourself ] ];					decoder: [ :x |						(x at: 'type') = 'pair'							ifTrue: [ Array with: (x at: 'key') with: (x at: 'value') ]							ifFalse: [ (x at: 'key') -> (x at: 'value')] ] ];			for: #ArrayOfAssocOrPair customDo: [ :mapping |				mapping listOfType: Array andElementSchema: #AssocOrPair ];			yourself ].	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #ArrayOfAssocOrPair ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #ArrayOfAssocOrPair.	self assert: result equals: data! !!NeoJSONMappingTests methodsFor: 'testing'!testSymbolOrStringInstVarMapping	| data out1 out2 result1 result2 |	data := Array with: 1@2 with: 3@4.	out1 := String streamContents: [ :out |		(NeoJSONWriter on: out)			for: Point do: [ :mapping | mapping mapInstVars: #(x y) ];			nextPut: data ].	result1 := (NeoJSONReader on: out1 readStream)		for: Point do: [ :mapping | mapping mapInstVars: #(x y) ];		nextListAs: Point.	self assert: result1 equals: data.	out2 := String streamContents: [ :out |		(NeoJSONWriter on: out)			for: Point do: [ :mapping | mapping mapInstVars: #('x' 'y') ];			nextPut: data ].	result2 := (NeoJSONReader on: out1 readStream)		for: Point do: [ :mapping | mapping mapInstVars: #('x' 'y') ];		nextListAs: Point.	self assert: result2 equals: data! !!NeoJSONMappingTests methodsFor: 'testing'!testVirtualTransferObject	| data customMapping extraJson json result |	data := NeoJSONObject new data: (Array with: 1@1 with: 2@2).	extraJson := '{"foo":1,"data":[{"x":1,"y":1},{"x":2,"y":2,"z":-1}]}'.	"The idea here is that we are not interested in the top level object just in its data property, 	which should be of a specific type, hence we create a virtual transfer object"	customMapping := [ :mapper |		mapper			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			for: #TransferObject do: [ :mapping |				mapping subjectClass: NeoJSONObject.				(mapping mapAccessor: #data) valueSchema: #ArrayOfPoints ];			yourself ].	"By using NeoJSONObject accessors (#data & #data:) are translated to generic #at:[put:] messages.	A longer alternative is 	(mapping mapProperty: #data getter: [ :obj | obj at: #data ] setter: [ :obj :x | obj at: #data put: x]) valueSchema: #ArrayOfPoints	where the blocks give you the flexibility to use a plain Dictionary for example"	result := (customMapping value: (NeoJSONReader on: extraJson readStream)) nextAs: #TransferObject.	self assert: result equals: data.	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #TransferObject ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #TransferObject.	self assert: result equals: data! !!NeoJSONObjectTests methodsFor: 'testing'!testAtPath	| object |	object := NeoJSONObject newFrom:  (Array with:  #one -> ( NeoJSONObject newFrom:  (Array with:  #two -> ( NeoJSONObject newFrom: (Array with:  #three -> 42) ) ) )).	self assert: (object atPath: #(one two three)) equals: 42.	self assert: (object atPath: #(one two three)) equals: object one two three.		self assert: (object atPath: #(missing)) equals: nil.	self assert: (object atPath: #(one missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: object one two missing.		object := NeoJSONObject newFrom:  (Array with: #foo -> 42).	self assert: (object atPath: #(foo)) equals: 42.	self assert: (object atPath: #(foo)) equals: object foo.	self assert: (object atPath: #(foo)) equals: (object at: #foo).	self assert: (object atPath: #()) equals: object.	! !!NeoJSONObjectTests methodsFor: 'testing'!testAtPathPut	| object |	object := NeoJSONObject new.	object atPath: #(one test) put: 42.	self assert: (object atPath: #(one test)) equals: 42.	self assert: object one test equals: 42.	object atPath: #(one two three) put: #foo.	self assert: (object atPath: #(one two three)) equals: #foo.	self assert: object one two three equals: #foo.	object atPath: #(one two threeBis) put: #bar.	self assert: (object atPath: #(one two threeBis)) equals: #bar.	self assert: object one two threeBis equals: #bar.		self assert: object foo isNil.	self assert: (object atPath: #() put: 1) equals: object.	self assert: (object atPath: #(foo) put: 1) equals: 1.	self assert: (object atPath: #(foo)) equals: 1.	self assert: object foo equals: 1	 ! !!NeoJSONObjectTests methodsFor: 'testing'!testCRUD	| object |	object := NeoJSONObject new.	self assert: object isEmpty.	self assert: object foo equals: nil.	object foo: 123.	self assert: object foo equals: 123.	self assert: object printString equals: '{"foo":123}'.	object name: 'test'.	object value: Float pi.	self assert: object name equals: 'test'.	self assert: (object value closeTo: Float pi).	self assert: object keys asSet equals: #(foo name value) asSet.	object removeKey: #foo.	self assert: object foo equals: nil.	object removeAll.	self assert: object isEmpty! !!NeoJSONObjectTests methodsFor: 'testing'!testJSON	| data  json object |	data := NeoJSONObject newFrom: (Array with: #foo->1 with: #bar->2 with: #str->'Str!!' with: #bool->true with: #flt->1.5).	json := NeoJSONWriter toString: data .	object := NeoJSONObject fromString: json.	self assert: object class equals: NeoJSONObject.	self assert: object equals: data.	json := (NeoJSONWriter toString: object).	self assert: (NeoJSONObject fromString: json) equals: object! !!NeoJSONReaderTests methodsFor: 'testing'!testAllowNil	self 		should: [ 			(NeoJSONReader on: 'null' readStream)				mapInstVarsFor: Point;				nextAs: Point ] 		raise: NeoJSONParseError.	self		assert: ((NeoJSONReader on: 'null' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						nextAs: Point)		equals: nil.	self		assert: ((NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, null, { "x" : 3, "y" : -1 } ]' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						for: #ArrayOfPoints customDo: [ :mapping | mapping listOfElementSchema: Point ];						nextAs: #ArrayOfPoints)		equals: (Array with: 1 @ 2 with: nil with: 3 @ -1).! !!NeoJSONReaderTests methodsFor: 'testing'!testArrayOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			nextAs: #ArrayOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: (Array with: 1@2 with: -1@ -2) . 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: (Array with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing'!testArrayOfPointsUsingNextListAs	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapInstVarsFor: Point;			nextListAs: Point ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "y":-2, "x":-1 } ]') equals: (Array with: 1@2 with: -1@ -2) . 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: (Array with: Point new) ! !!NeoJSONReaderTests methodsFor: 'testing'!testAssociation	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Association do: [ :mapping |				mapping mapAccessors: #(key value) ]; 			nextAs: Association ].	self assert: (reader value: '{"key":"foo","value":42}') equals: 'foo' -> 42. 	self assert: (reader value: '{}') equals: Association new! !!NeoJSONReaderTests methodsFor: 'testing'!testBooleans	self assert: (NeoJSONReader on: 'true' readStream) next equals: true.	self assert: (NeoJSONReader on: 'false' readStream) next equals: false.	self should: [ (NeoJSONReader on: 'tru' readStream) next ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: 'falsE' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testByteArray	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: ByteArray customDo: [ :mapping |				mapping listOfType: ByteArray ];			nextAs: ByteArray ].	self assert: (reader value: '[ 1, 2, 3 ]') equals: #[1 2 3].	self assert: (reader value: '[ ]') equals: ByteArray new! !!NeoJSONReaderTests methodsFor: 'testing'!testDate	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Date customDo: [ :mapping |				mapping decoder: [ :string | Date fromString: string ] ];			nextAs: Date ].	self assert: (reader value: ' "2012-06-08" ') equals: (Date fromString: '2012-06-08') ! !!NeoJSONReaderTests methodsFor: 'testing'!testDateAndTime 	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: DateAndTime customDo: [ :mapping |				mapping decoder: [ :string | DateAndTime fromString: string ] ];			nextAs: DateAndTime ].	self 		assert: (reader value: ' "2012-02-14T16:40:18+01:00" ') 		equals: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)! !!NeoJSONReaderTests methodsFor: 'testing'!testFloats	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: ((reader value: '123.0') closeTo: 123.0).	self assert: ((reader value: '-123.0') closeTo: -123.0).	self assert: ((reader value: '123.0e0') closeTo: 123.0).	self assert: ((reader value: '123e6') closeTo: 123e6).	self assert: ((reader value: '123e+6') closeTo: 123e6).	self assert: ((reader value: '123e-6') closeTo: 123e-6).	self assert: ((reader value: '123E6') closeTo: 123e6).	self assert: ((reader value: '123E+6') closeTo: 123e6).	self assert: ((reader value: '123E-6') closeTo: 123e-6).	self assert: ((reader value: '-123e6') closeTo: -123e6).	self assert: ((reader value: '-123e-6') closeTo: -123e-6).	self assert: ((reader value: '-123E6') closeTo: -123e6).	self assert: ((reader value: '-123E-6') closeTo: -123e-6).	self assert: ((reader value: '3.14159') closeTo: Float pi).	self assert: ((reader value: '0.123e6') closeTo: 0.123e6).	self assert: ((reader value: '0.123e-6') closeTo: 0.123e-6).	self assert: ((reader value: '-0.123E6') closeTo: -0.123e6).	self assert: ((reader value: '-0.123E-6') closeTo: -0.123e-6).! !!NeoJSONReaderTests methodsFor: 'testing'!testIntegers	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '123') equals: 123.	self assert: (reader value: '00123') equals: 123.	self assert: (reader value: '-123') equals: -123.	self assert: (reader value: '-0123') equals: -123.	self assert: (reader value: '0') equals: 0.	self assert: (reader value: '-0') equals: 0.	self assert: (reader value: '00') equals: 0.	self assert: (reader value: ' 123	') equals: 123.	self should: [ reader value: '+1' ] raise: NeoJSONParseError.	self should: [ reader value: ' - ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testLists	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '[1,2,3]') equals: #(1 2 3).	self assert: (reader value: '[]') equals: #().	self assert: (reader value: ' [ 1 , 2 , 3 ] ') equals: #(1 2 3).	self assert: (reader value: ' [ ] ') equals: #().	self should: [ reader value: '[1,]' ] raise: NeoJSONParseError. 	self should: [ reader value: '[' ] raise: NeoJSONParseError.	self should: [ reader value: ']' ] raise: NeoJSONParseError.	self should: [ reader value: '[}' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing'!testMaps	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '{"x":1,"y":2}') equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: '{}') equals: Dictionary new.	self assert: (reader value: ' { "x" : 1 , "y" : 2 } ' ) equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: ' { } ') equals: Dictionary new.	self should: [ reader value: '{"foo":}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{"foo":9,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{9:true,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{' ] raise: NeoJSONParseError.	self should: [ reader value: '}' ] raise: NeoJSONParseError.	self should: [ reader value: '{]' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing'!testNextStringAsHex	| string |	string := (NeoJSONReader on: '"466F6F2062617221"' readStream)		for: #StringAsHex			customDo: [ :mapping | 					mapping						encoder: [ :x | x asByteArray hex asUppercase ];						decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];		nextAs: #StringAsHex.	self assert: string equals: 'Foo bar!!'! !!NeoJSONReaderTests methodsFor: 'testing'!testNonBMPCharacterDecoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string object |	string := 16r1D11E asCharacter asString. "MUSICAL SYMBOL G CLEF"	object := (NeoJSONReader fromString: '"\uD834\uDD1E"').	self assert: object equals: string! !!NeoJSONReaderTests methodsFor: 'testing'!testNull	self assert: (NeoJSONReader on: 'null' readStream) next equals: nil.	self assert: (NeoJSONReader on: '	null ' readStream) next equals: nil.	self should: [ (NeoJSONReader on: '	nil ' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testOrderedCollection	| json list |	json := '[ 1, 2, 3 ]'.	list := (NeoJSONReader on: json readStream) 		listClass: OrderedCollection;		next.	self 		assert: list 		equals: (OrderedCollection with: 1 with: 2 with: 3).	self 		assert: list class 		equals: OrderedCollection! !!NeoJSONReaderTests methodsFor: 'testing'!testOrderedCollectionOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #OrderedCollectionOfPoints customDo: [ :mapping |				mapping listOfType: OrderedCollection andElementSchema: Point ];			nextAs: #OrderedCollectionOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: (Array with: 1@2 with: -1@ -2) asOrderedCollection. 	self assert: (reader value: '[ ]') equals: OrderedCollection new.	self assert: (reader value: '[ { } ]') equals: (OrderedCollection with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing'!testParseErrors	self should: [ NeoJSONReader fromString: 'zero' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '#' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '@' ] raise: NeoJSONParseError.		self should: [ (NeoJSONReader on: '[1,2,3]true' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '{"foo":1}"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '[]"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) nextAs: Point ].	self should: [ reader value: '{"x":1,"y":2}' ] raise: NeoJSONMappingNotFound! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint1	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point setX: value setY: point y ].				mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point setX: point x setY: value ]. ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint2	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapAllInstVarsFor: Point;			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint3	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPointUsingAsString	| point |	point := (NeoJSONReader on: '{"x":"1","y":"2"}' readStream)		for: Point			do: [ :mapping | 					(mapping 						mapProperty: #x 						getter: [ :object | object x ] 						setter: [ :object :value | object setX: value setY: object y ])						valueSchema: #AsString.					(mapping						mapProperty: #y						getter: [ :object | object y ]						setter: [ :object :value | object setX: object x setY: value ]) 						valueSchema: #AsString ];		for: #AsString			customDo: [ :mapping | 					mapping						encoder: [ :x | x asString ];						decoder: [ :x | x asNumber ] ];		nextAs: Point.	self assert: point equals: 1 @ 2! !!NeoJSONReaderTests methodsFor: 'testing'!testPropertyNamesAsSymbols	| json map |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	map := (NeoJSONReader on: json readStream) 		propertyNamesAsSymbols: true; 		next.	self 		assert: map 		equals: (Dictionary new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self assert: (map keys allSatisfy: [ :each | each isSymbol ])! !!NeoJSONReaderTests methodsFor: 'testing'!testSmallDictionary	| json map smallDictionaryClass |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	smallDictionaryClass := Smalltalk at: #SmallDictionary ifAbsent: [ Dictionary ].	map := (NeoJSONReader on: json readStream) 		mapClass: smallDictionaryClass;		next.	self 		assert: map 		equals: (smallDictionaryClass new at: 'x' put: true; at: 'y' put: false; at: 'key-1' put: 1; yourself).	self 		assert: map class 		equals: smallDictionaryClass! !!NeoJSONReaderTests methodsFor: 'testing'!testStrings	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '"foo"') equals: 'foo'.	self assert: (reader value: '""') equals: ''.	self assert: (reader value: '"Foo BAR"') equals: 'Foo BAR'.	self assert: (reader value: '" foo "') equals: ' foo '.	self assert: (reader value: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'lve en Franais'.	self 		assert: (reader value: '"\"\\\/\t\r\n\f\b"') 		equals: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )).	self should: [ reader value: '"open' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uAA"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uZZ"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\x"' ] raise: NeoJSONParseError.	self should: [ reader value: ' " ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testSymbol	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Symbol customDo: [ :mapping |				mapping decoder: [ :string | string asSymbol ] ];			nextAs: Symbol ].	self assert: (reader value: ' "foo" ') equals: #foo.	self assert: (reader value: ' "FOO-1" ') equals: #'FOO-1'! !!NeoJSONReaderTests methodsFor: 'testing'!testTime	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Time customDo: [ :mapping |				mapping decoder: [ :string | Time fromString: string ] ];			nextAs: Time ].	self assert: (reader value: ' "14:30:08" ') equals: (Time hour: 14 minute: 30 second: 8)! !!NeoJSONWriteReadAsciiOnlyTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) asciiOnly: true; nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadMockStreamTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: (NeoJSONMockStream on: stream))			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: (NeoJSONMockStream on: json readStream)) next ! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: 'one' put: NeoJSONTestObject2 example1;		at: 'two' put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toStringPretty: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject1	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject3	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadTests methodsFor: 'testing'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: 'one' put: NeoJSONTestObject2 example1;		at: 'two' put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toString: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadTests methodsFor: 'testing'!testFloats	| objects |	objects := OrderedCollection new add: Float pi; add: 1.0; add: -1.0; add: 0.0; add: 1.5e6; add: -1.5e6; add: 1.5e-6; add: -1.5e-6; yourself.	(self writeRead: objects) 		with: objects 		do: [ :first :second | self assert: (first closeTo: second) ]! !!NeoJSONWriteReadTests methodsFor: 'testing'!testIntegers	| objects |	objects := Array with: 1 with: -1 with: 0 with: 123467890 with: -1234567890.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testLists	| objects |	objects := Array with: #(1 2 3) with: #() with: #( 'foo' 'bar').	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testMaps	| objects |	objects := Array 		with: Dictionary new		with: (Dictionary with: 'x' -> 1)		with: (Dictionary newFromPairs: #( 'foo' true 'bar' false 'zero' 0 'null' nil 'string' 'Hello World!!' )).	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject1	| json |	json := NeoJSONWriter toString: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject3	| json |	json := NeoJSONWriter toString: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testSpecials	| objects |	objects := Array with: true with: false with: nil.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testStrings	| objects |	objects := OrderedCollection new		add: 'foo'; add: 'Foo BAR'; add: ''; add: '	\\'''; 		add: 'lve en Franais';		add: (Character codePoint: 12354) asString; "HIRAGANA LETTER A" 		yourself;		asArray.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriterTests methodsFor: 'testing'!testAsciiOnlyStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				asciiOnly: true;				nextPut: object ] ].	self assert: (writer value: 'lve franais') equals: '"\u00E9l\u00E8ve fran\u00E7ais"'.	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing'!testAssociation	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Association do: [ :mapping |					mapping mapAccessors: #(key value) ]; 				nextPut: object ] ].	self assert: (writer value: 'foo' -> 42) equals: '{"key":"foo","value":42}'.	self assert: (writer value: Association new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testBooleans	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: true) equals: 'true'.	self assert: (writer value: false) equals: 'false'.! !!NeoJSONWriterTests methodsFor: 'testing'!testByteArray	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #[1 2 3]) equals: '[1,2,3]'.	self assert: (writer value: #[]) equals: '[]'! !!NeoJSONWriterTests methodsFor: 'testing'!testDate	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Date customDo: [ :mapping |					mapping encoder: [ :date | date yyyymmdd ] ];				nextPut: object ] ].	self assert: (writer value: (Date fromString: '2012-06-08')) equals: '"2012-06-08"'! !!NeoJSONWriterTests methodsFor: 'testing'!testDateAndTime 	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: DateAndTime customDo: [ :mapping |					mapping encoder: [ :dateAndTime | dateAndTime printString ] ];				nextPut: object ] ].	self 		assert: (writer value: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)) 		equals: '"2012-02-14T16:40:18+01:00"'! !!NeoJSONWriterTests methodsFor: 'testing'!testFloats	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123.0'.	self assert: (writer value: -123.0) equals: '-123.0'.	self assert: (writer value: 0.0) equals: '0.0'.! !!NeoJSONWriterTests methodsFor: 'testing'!testIntegers	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123) equals: '123'.	self assert: (writer value: -123) equals: '-123'.	self assert: (writer value: 0) equals: '0'.! !!NeoJSONWriterTests methodsFor: 'testing'!testLists	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #(1 2 3)) equals: '[1,2,3]'.	self assert: (writer value: #()) equals: '[]'.! !!NeoJSONWriterTests methodsFor: 'testing'!testListsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	#( OrderedCollection LinkedList ByteArray IntegerArray SortedCollection ) do: [ :each |		Smalltalk at: each ifPresent: [ :collectionClass |			self assert: (writer value: (collectionClass withAll: #(1 2 3))) equals: '[1,2,3]'.			self assert: (writer value: collectionClass new) equals: '[]' ] ]! !!NeoJSONWriterTests methodsFor: 'testing'!testMapKeysMustBeStrings	self should: [ NeoJSONWriter toString: { 1->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { true->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { nil->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { #()->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { Dictionary new->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { Float pi->#a } asDictionary ] raise: Error.! !!NeoJSONWriterTests methodsFor: 'testing'!testMaps	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: ((writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) includesSubstring: '"x":1').	self assert: ((writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) includesSubstring: '"y":2').	self assert: (writer value: Dictionary new) equals: '{}'.! !!NeoJSONWriterTests methodsFor: 'testing'!testMapsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (IdentityDictionary newFromPairs: #( 'x' 1))) equals: '{"x":1}'.	self assert: (writer value: IdentityDictionary new) equals: '{}'.	#( SmallDictionary OrderedDictionary OrderedIdentityDictionary ) do: [ :each |		| dictionaryClass |		dictionaryClass := Smalltalk at: each ifAbsent: [ nil ].		dictionaryClass ifNotNil: [				self assert: (writer value: (dictionaryClass new at: 'x' put: 1; at: 'y' put: 2; yourself)) equals: '{"x":1,"y":2}'.			self assert: (writer value: dictionaryClass new) equals: '{}'] ]! !!NeoJSONWriterTests methodsFor: 'testing'!testNextPutStringAsHex	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: #StringAsHex					customDo: [ :mapping | 							mapping								encoder: [ :x | x asByteArray hex asUppercase ];								decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];				nextPut: 'Foo bar!!' as: #StringAsHex ].	self assert: output equals: '"466F6F2062617221"'! !!NeoJSONWriterTests methodsFor: 'testing'!testNonBMPCharacterEncoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string json |	string := 16r1D11E asCharacter asString. "MUSICAL SYMBOL G CLEF"	json := String streamContents: [ :out |		(NeoJSONWriter on: out) asciiOnly: true; nextPut: string ].	self assert: json equals: '"\uD834\uDD1E"'! !!NeoJSONWriterTests methodsFor: 'testing'!testNull	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: nil) equals: 'null'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self should: [ writer value: 1@2 ] raise: NeoJSONMappingNotFound! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint1	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point x: value ].					mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point y: value ]. ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint2	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint3	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapInstVars: #(x y) ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPointUsingAsString	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: Point					do: [ :mapping | 							(mapping 								mapProperty: #x 								getter: [ :object | object x ] 								setter: [ :object :value | object setX: value setY: object y ])								valueSchema: #AsString.							(mapping								mapProperty: #y								getter: [ :object | object y ]								setter: [ :object :value | object setX: object x setY: value ]) 								valueSchema: #AsString ];				for: #AsString					customDo: [ :mapping | 							mapping								encoder: [ :x | x asString ];								decoder: [ :x | x asNumber ] ];				nextPut: 1 @ 2 ].	self assert: output equals: '{"x":"1","y":"2"}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPointWriteNil	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				writeNil: true;				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{"x":null,"y":null}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPreservePropertyOrder	| writer testObject |	(testObject := NeoJSONTestObject2 new)		id: 123;		width: 100;		height: 50;		data: 'test'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(id width height data) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"id":123,"width":100,"height":50,"data":"test"}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(width height data id) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"width":100,"height":50,"data":"test","id":123}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(data id height width) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"data":"test","id":123,"height":50,"width":100}'.! !!NeoJSONWriterTests methodsFor: 'testing'!testStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing'!testSymbol	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #foo) equals: '"foo"'.	self assert: (writer value: #'FOO-1') equals: '"FOO-1"'! !!NeoJSONWriterTests methodsFor: 'testing'!testTime	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Time customDo: [ :mapping |					mapping encoder: [ :time | time printString ] ];				nextPut: object ] ].	self assert: ((writer value: (Time fromSeconds: 52208)) includesSubstring: '2:30:08')! !!NeoJSONBenchmark methodsFor: 'initialize-release'!initialize	super initialize.	objects := Array new: 1000.	1 to: 1000 do: [ :each |		| map |		(map := Dictionary new)			at: 'id' put: each;			at: 'name' put: 'Name-', each asString;			at: 'enabled' put: (#( true false) at: (each \\ 2) + 1);			at: 'color' put: (#( 'red' 'green' 'blue' ) at: (each \\ 3) + 1);			at: 'value' put: each + each / 1000.0.		objects at: each put: map ].	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]		! !!NeoJSONBenchmark methodsFor: 'public'!read	^ (NeoJSONReader on: json readStream) next! !!NeoJSONBenchmark methodsFor: 'public'!write	^ String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]! !!NeoJSONBenchmark methodsFor: 'public'!writePrettyPrintedRead	| output |	output := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: objects ].	^ (NeoJSONReader on: output readStream) 		next! !!NeoJSONMockStream class methodsFor: 'instance creation'!on: stream	^ self new		stream: stream;		yourself! !!NeoJSONMockStream methodsFor: 'testing'!atEnd	^ stream atEnd! !!NeoJSONMockStream methodsFor: 'accessing'!close	^ stream close! !!NeoJSONMockStream methodsFor: 'accessing'!next	^ stream next! !!NeoJSONMockStream methodsFor: 'accessing'!nextPut: character	^ stream nextPut: character! !!NeoJSONMockStream methodsFor: 'accessing'!nextPutAll: string	^ stream nextPutAll: string! !!NeoJSONMockStream methodsFor: 'accessing'!peek	^ stream peek! !!NeoJSONMockStream methodsFor: 'accessing'!peekFor: char	^ stream peekFor: char! !!NeoJSONMockStream methodsFor: 'accessing'!space	^ stream space! !!NeoJSONMockStream methodsFor: 'initialize-release'!stream: anObject	stream := anObject! !!NeoJSONTestObject1 class methodsFor: 'instance creation'!example1	^ self new		id: 123;		name: 'Example1';		timestamp: (DateAndTime year: 2012 month: 06 day: 08 hour: 14 minute: 30 second: 15 offset: 1 hour);		points: (Array with: 1@2 with: 3@4);		bytes: #[ 2 4 6 8 ];		yourself! !!NeoJSONTestObject1 class methodsFor: 'accessing'!neoJsonMapping: mapper	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper mapAllInstVarsFor: Point.	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]! !!NeoJSONTestObject1 methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			name = anObject name				and: [					timestamp = anObject timestamp						and: [							points = anObject points								and: [ bytes = anObject bytes ] ] ] ]! !!NeoJSONTestObject1 methodsFor: 'accessing'!bytes	^ bytes! !!NeoJSONTestObject1 methodsFor: 'accessing'!bytes: byteArray	bytes := byteArray! !!NeoJSONTestObject1 methodsFor: 'comparing'!hash	^ id hash bitXor: (name hash bitXor: (timestamp hash bitXor: (points hash bitXor: bytes hash)))! !!NeoJSONTestObject1 methodsFor: 'accessing'!id	^ id! !!NeoJSONTestObject1 methodsFor: 'accessing'!id: integer	id := integer! !!NeoJSONTestObject1 methodsFor: 'accessing'!name	^ name! !!NeoJSONTestObject1 methodsFor: 'accessing'!name: string	name := string! !!NeoJSONTestObject1 methodsFor: 'accessing'!points	^ points! !!NeoJSONTestObject1 methodsFor: 'accessing'!points: arrayOfPoints	points := arrayOfPoints ! !!NeoJSONTestObject1 methodsFor: 'accessing'!timestamp	^ timestamp! !!NeoJSONTestObject1 methodsFor: 'accessing'!timestamp: dateAndTime 	timestamp := dateAndTime ! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark10k	"self benchmark10k"		self benchmark: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark10kAsDictionary	"self benchmark10kAsDictionary"		self benchmarkAsDictionary: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark200k	"self benchmark200k"		self benchmark: 200000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark: count	"self benchmark: 1000"		| collection json size |	collection := Array new: count withAll: self example1.	size := 2 + (count * (NeoJSONWriter toString: self example1) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: (Array with: count) );		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: (Array with: count) );		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmarkAsDictionary: count	"self benchmarkAsDictionary: 1000"		| collection json size |	collection := Array new: count withAll: self example1 asDictionary.	size := 2 + (count * (NeoJSONWriter toString: self example1 asDictionary) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: (Array with: count) );		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: (Array with: count) );		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'instance creation'!example1	^ self new		id: 13;		width: 250;		height: 110;		data: (String new: 512 withAll: $a);		yourself! !!NeoJSONTestObject2 class methodsFor: 'accessing'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id width height data) ] ! !!NeoJSONTestObject2 methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			height = anObject height				and: [					width = anObject width						and: [							data = anObject data ] ] ]! !!NeoJSONTestObject2 methodsFor: 'converting'!asDictionary	^ Dictionary new		at: #id put: id;		at: #height put: height;		at: #width put: width;		at: #data put: data;		yourself! !!NeoJSONTestObject2 methodsFor: 'accessing'!data	^ data! !!NeoJSONTestObject2 methodsFor: 'accessing'!data: anObject	data := anObject! !!NeoJSONTestObject2 methodsFor: 'comparing'!hash	^ id hash bitXor: (width hash bitXor: (height hash bitXor: data hash))! !!NeoJSONTestObject2 methodsFor: 'accessing'!height	^ height! !!NeoJSONTestObject2 methodsFor: 'accessing'!height: anObject	height := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing'!id	^ id! !!NeoJSONTestObject2 methodsFor: 'accessing'!id: anObject	id := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing'!width	^ width! !!NeoJSONTestObject2 methodsFor: 'accessing'!width: anObject	width := anObject! !!NeoJSONTestObject3 class methodsFor: 'instance creation'!example1	^ super example1		data: (String new: 8 withAll: $a);		color: 'red';		transparent: true;		yourself! !!NeoJSONTestObject3 class methodsFor: 'accessing'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"		super neoJsonMapping: mapper.	mapper for: self do: [ :mapping |		mapping mapInstVars: #(color transparent) ]! !!NeoJSONTestObject3 methodsFor: 'comparing'!= anObject	^ super = anObject 		and: [ color = anObject color			and: [ transparent = anObject transparent ] ]! !!NeoJSONTestObject3 methodsFor: 'converting'!asDictionary	^ super asDictionary		at: #color put: color;		at: #transparent put: transparent;		yourself! !!NeoJSONTestObject3 methodsFor: 'accessing'!color	^ color! !!NeoJSONTestObject3 methodsFor: 'accessing'!color: anObject	color := anObject! !!NeoJSONTestObject3 methodsFor: 'accessing'!transparent	^ transparent! !!NeoJSONTestObject3 methodsFor: 'accessing'!transparent: anObject	transparent := anObject! !!NeoJSONValidation methodsFor: 'private'!closeLog	logStream ifNotNil: [ 		logStream close.		logStream := nil ].	^ self logFile exists		ifTrue: [ self logFile contents ] 		ifFalse: [ 'log file is empty' ]! !!NeoJSONValidation methodsFor: 'private'!ensureLog	logStream ifNil: [ 		logStream := self logFile ensureDelete; writeStream. 		logStream setToEnd ]	! !!NeoJSONValidation methodsFor: 'accessing'!gitDirectory	^ gitDirectory ifNil: [ gitDirectory := FileLocator home / #Develop / #git ]! !!NeoJSONValidation methodsFor: 'accessing'!gitDirectory: fileReference	gitDirectory := fileReference! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteDirectory	^ self gitDirectory / #JSONTestSuite! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingDirectory	^ self jsonTestSuiteDirectory / 'test_parsing'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingFailFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'n_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingInfoFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'i_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingPassFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'y_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestTransformDirectory	^ self jsonTestSuiteDirectory / 'test_transform'! !!NeoJSONValidation methodsFor: 'private'!log: message	self ensureLog.	logStream nextPutAll: message; lf; flush! !!NeoJSONValidation methodsFor: 'private'!logFile	^ 'neo-json-validation.log' asFileReference! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkDataDirectory	^ self nativeJsonBenchmarkDirectory / #data! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkDirectory	^ self gitDirectory / 'nativejson-benchmark'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerDirectory	^ self nativeJsonBenchmarkDataDirectory / #jsonchecker! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerFailFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'fail*.json'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerPassFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'pass*.json'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkRoundTripDirectory	^ self nativeJsonBenchmarkDataDirectory / #roundtrip! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkRoundTripFiles	^ self nativeJsonBenchmarkRoundTripDirectory children! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingFailures	^ self		validateFiles: self jsonTestSuiteTestParsingFailFiles 		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingInfo	^ self		validateFiles: self jsonTestSuiteTestParsingInfoFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingPasses	^ self		validateFiles: self jsonTestSuiteTestParsingPassFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkJsonCheckerFailures	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerFailFiles		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkJsonCheckerPasses	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerPassFiles		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkRoundTrip	^ self 		validateFiles: self nativeJsonBenchmarkRoundTripFiles		usingTest: [ :file |			| data json |			data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ].			json := NeoJSONWriter toString: data.			json = file contents ]! !!NeoJSONValidation methodsFor: 'private'!validateFiles: files usingTest: block	| total succeeded failed |	total := succeeded := failed := 0.	files do: [ :file | 		| success |		self log: 'Running ' , file pathString.		self log: ([ file contents contractTo: 64 ] on: Error do: [ :exception | exception printString ]).		success := [ block value: file ]			on: Error			do: [ :exception | self log: '  Errored. ' , exception printString. false ].		total := total + 1.		success			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed := failed + 1 ].		self log: (success ifTrue: [ '  Succeeded' ] ifFalse: [ '  Failed' ]); log: '' ].	self log: ('{1} total = {2} succeeded + {3} failed' format: (Array with: total with: succeeded with: failed) ).	^ self closeLog! !"Neo-JSON-Tests"!----SNAPSHOT----2020-03-14T22:13:54.615771+02:00 SlobodaServer.image priorSource: 100!----SNAPSHOT----2020-03-14T22:15:34.016949+02:00 SlobodaServer.image priorSource: 204327!----SNAPSHOT----2020-03-14T22:15:49.235509+02:00 SlobodaServer.image priorSource: 204415!----QUIT----2020-03-14T22:31:34.035056+02:00 SlobodaServer.image priorSource: 204506!----QUIT----2020-03-14T22:35:15.152993+02:00 Pharo.image priorSource: 204597!or enabled: false.
!----End fileIn----!"For supressing lost-changes-recovery dialog on start-up"
EpLostChangesDetector enabled: false.
!----End fileIn----!----SNAPSHOT----2020-03-15T06:58:09.72308+00:00 Pharo.image priorSource: 204597!----SNAPSHOT----2020-03-15T06:58:15.16041+00:00 Pharo.image priorSource: 204924!----QUIT----2020-03-15T08:59:42.096736+02:00 Pharo.image priorSource: 205006!"For supressing lost-changes-recovery dialog on start-up"
EpLostChangesDetector enabled: false.
!----End fileIn----!"For supressing lost-changes-recovery dialog on start-up"
EpLostChangesDetector enabled: false.
!----End fileIn----!